import com.rameses.annotations.*
import java.rmi.server.UID

class RPTReceiptService
{
	@PersistenceContext('main')
	def em
    
    @Service('XReceiptService')
	def receiptSvc
    
    @Service('DateService')
	def dateSvc

	@Service('NumberService')
	def numSvc

	@Service('RPTUtil')
	def util
	
	@Service('Var')
	def var 

	def SCHEMA_RECEIPT 		= 'rptreceipt:rptreceipt'
	def SCHEMA_ITEM 		= 'rptreceipt:rptreceiptitem'
	def SCHEMA_MAPPING 		= 'rptreceipt:mapping'

	def RECEIPT_TYPE_ONLINE = 'online'
	def RECEIPT_TYPE_MANUAL = 'manual'

	def MAX_ITEM_COUNT 		= 5

	/*--------------------------------------------------------------------------------------
	* Receipt does not contain any "items" yet. The "items" must be build from the "rptitems"
	* data which are the items to be paid. The rptitems list is assumed to be sorted 
	* in ascending order by ledger and year,qtr 
	--------------------------------------------------------------------------------------*/

	@ProxyMethod
	public def createReceipt(receipt) {
		if (! var.lgu_type) 
			throw new Exception('Var lgu_type must be set.')
		if ('city/province/municipality'.indexOf(var.lgu_type.toString().toLowerCase()) < 0 )
			throw new Exception('Lgu Type ' + var.lgu_type + ' is invalid.')
		if (receipt.rptitems.size() == 0)
			throw new Exception('Items for payment are required.')
		
		//create receipt
		createReceiptItems(receipt)
		receiptSvc.createReceipt(receipt)

		//create rptreceipt
		def pdate = dateSvc.parseDate(receipt.txndate, null)
		receipt.year = pdate.year
		receipt.qtr = pdate.qtr
		receipt.month = pdate.month
		receipt.day = pdate.day
		receipt.type = RECEIPT_TYPE_ONLINE

		em.validate(SCHEMA_RECEIPT, receipt)
		em.create(SCHEMA_RECEIPT, receipt)

		//TODO: clear rptitems and items after saving
		//to avoid returing it to the client
		receipt.rptitems.each{
			calculateItemShares(it)
			em.validate(SCHEMA_ITEM, it)
			em.create(SCHEMA_ITEM, it)
			updateLedgerPaymentInfo(it)
		}

		receipt.items.each{
			em.validate(SCHEMA_MAPPING, it)
			em.create(SCHEMA_MAPPING, it)
		}
		
		return receipt 
	}


	@ProxyMethod
	public def voidReceipt( receipt ) {
		def paidledgers = em.sqlContext.createNamedQuery('rptreceipt:getPaidLedgers')
							.setParameter('rptreceiptid', receipt.objid)
							.resultList 

		paidledgers.each{
			def firstpaiditem = em.sqlContext.createNamedQuery('rptreceipt:getFirstPaidLedgerItem')
					.setParameter('rptreceiptid', receipt.objid)
					.singleResult

			//update ledger last year and qtr paid
			def lastyearpaid = (firstpaiditem.qtr == 1 ? firstpaiditem.year - 1 : firstpaiditem.year )
			def lastqtrpaid = (firstpaiditem.qtr == 1 ? 4 : firstpaiditem.qtr - 1 )

			em.sqlContext.createNamedExecutor('rptreceipt:voidLedgerPayment')
					.setParameter('objid', firstpaiditem.rptledgerid)
					.setParameter('lastyearpaid', lastyearpaid)
					.setParameter('lastqtrpaid', lastqtrpaid)
					.execute()
		}

		//void  basic and sef payment
		em.sqlContext.createNamedExecutor('rptreceipt:voidLedgerItemPayment')
				.setParameter('rptreceiptid', receipt.objid)
				.execute()
		
	}



	void updateLedgerPaymentInfo(item){
		//update basicpaid and sefpaid fields 
		// if partialled, deduct also the partial interest and discount 
		def basicintpaid = 0.0
		def basicdisctaken = 0.0
		def sefintpaid = 0.0
		def sefdisctaken = 0.0

		if ( item.partialled){
			basicintpaid = item.basicint
			basicdisctaken = item.basicdisc 
			sefintpaid = item.sefint 
			sefdisctaken = item.sefdisc 
		}


		em.sqlContext.createNamedExecutor('rptreceipt:updateLedgerItemPaidInfo')
				.setParameter('objid', item.rptledgeritemid)
				.setParameter('basicpaid', item.basic)
				.setParameter('basicintpaid', basicintpaid)
				.setParameter('basicdisctaken', basicdisctaken)
				.setParameter('sefpaid', item.sef)
				.setParameter('sefintpaid', sefintpaid)
				.setParameter('sefdisctaken', sefdisctaken)
				.execute()

		em.sqlContext.createNamedExecutor('rptreceipt:updateLedgerLastYearQtrPaid')
				.setParameter('objid', item.rptledgerid)
				.setParameter('lastyearpaid', item.year)
				.setParameter('lastqtrpaid', (item.qtr == 0 ? 4 : item.qtr))
				.setParameter('lastreceiptid', item.rptreceiptid)
				.execute()
	}

	void createReceiptItems(receipt){
		receipt.items = []
		receipt.rptitems.each{ item ->
			receipt.items += createItem(receipt.objid, item.objid, item.basicacctid, item.basic - item.basicdisc, buildRemarks(item))
			if (item.basicint > 0.0){
				receipt.items += createItem(receipt.objid, item.objid, item.basicintacctid, item.basicint, buildRemarks(item))
			}
			receipt.items += createItem(receipt.objid, item.objid, item.sefacctid, item.sef - item.sefdisc, buildRemarks(item))
			if (item.sefint > 0.0){
				receipt.items += createItem(receipt.objid, item.objid, item.sefintacctid, item.sefint, buildRemarks(item))
			}
		}
	}

	def buildRemarks(item){
		if ( item.qtr == 0)
			return item.year 
		return item.qtr +'qtr, ' + item.year 
	}

	def createItem(receiptid, itemid, acctid, amount, remarks){
		def receiptitemid = util.generateId('RI')
		return [
			objid 		: receiptitemid,
			receiptid	: receiptid,
			acctid 		: acctid,
			amount 		: amount,
			remarks		: remarks,

			receiptitemid 	 : receiptitemid,
			rptreceiptitemid : itemid,
		]
	}

	void calculateItemShares(item){
		item.citybasic 		= 0.0;
		item.citybasicint 	= 0.0;
		item.citysef 		= 0.0;
		item.citysefint 	= 0.0;
		item.provbasic 		= 0.0;
		item.provbasicint 	= 0.0;
		item.provsef 		= 0.0;
		item.provsefint 	= 0.0;
		item.munibasic 		= 0.0;
		item.munibasicint 	= 0.0;
		item.munisef 		= 0.0;
		item.munisefint 	= 0.0;

		def basic = item.basic - item.basicdisc 
		def sef = item.sef - item.sefdisc 

		if (var.lgu_type == 'city') {
			item.citybasic 		= numSvc.round( basic * util.toDecimal(var.rptc_city_basic_rate))
			item.citybasicint 	= numSvc.round( item.basicint * util.toDecimal(var.rptc_city_basic_rate))
			item.citysef 		= item.sef
			item.citysefint 	= item.sefint
			item.brgybasic 		= basic - item.citybasic
			item.brgybasicint 	= item.basicint - item.citybasicint
			item.brgysef 		= 0.0
			item.brgysefint 	= 0.0
		}
		else {
			item.provbasic 		= numSvc.round( basic * util.toDecimal(var.rptc_province_basic_rate))
			item.provbasicint 	= numSvc.round( item.basicint * util.toDecimal(var.rptc_province_basic_rate))
			item.provsef 		= numSvc.round( sef * util.toDecimal(var.rptc_province_sef_rate))
			item.provsefint 	= numSvc.round( item.sefint * util.toDecimal(var.rptc_province_sef_rate))

			item.munibasic 		= numSvc.round( basic * util.toDecimal(var.rptc_municipality_basic_rate))
			item.munibasicint 	= numSvc.round( item.basicint * util.toDecimal(var.rptc_municipality_basic_rate))
			item.munisef 		= sef - item.provsef
			item.munisefint 	= item.sefint - item.provsefint

			item.brgybasic 		= basic - item.provbasic - item.munibasic 
			item.brgybasicint 	= item.basicint - item.provbasicint - item.munibasicint 
			item.brgysef 		= 0.0
			item.brgysefint 	= 0.0
		}
	}

}
