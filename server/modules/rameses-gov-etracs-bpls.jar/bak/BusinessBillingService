import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;

public class BusinessBillingService {

	@PersistenceContext("main")
	def em;
	
	@Service("NumberService")
	def numSvc;

	/**
	* gets the bill items based on the business application  
	*/
	@ProxyMethod
	public def getBilling( def o ) {
		
		int qtr = o.qtr;
		int year = o.year;
		def appid = o.appid;
		def businessid = o.businessid;

		//get unpaid and split into quarters for items that allow quarter payment
		def arrears = em.sqlContext.createNamedQuery( "businessreceivable:getOpenItems" ).setParameters(o).resultList;
		def billitems = [];
		
		arrears.each { i->
			if(i.allowqtr==1) {
				int lq = (i.lastqtrpaid==null)?0:i.lastqtrpaid;
				if(qtr>i.lastqtrpaid) {
					((lq+1)..qtr).each { q-> 
						def m = [:]
						m.payoption = year+"-"+q;
						m.refid = i.refid;
						m.year = year;
						m.qtr = q;
						m.sortindex = 10+q;	//this is just to sort quarterly from full payment
						m.lob = i.lob;
						m.item = i.item;
						m.principalpaid = (q!=4) ? i.qtrpayment : i.amount-(i.qtrpayment*3);
						m.partialprincipal = 0;
						billitems << m; 
					}
				}

			}
			else {
				i.payoption = "Full";
				i.sortindex = 0;
				i.qtr = 1;
				i.year = year;
				i.principalpaid = i.remove("amount");
				i.partialprincipal = 0;
				billitems << i;
			}
		}
		
		//mock the computation from the rules. assume it already computed the values
		billitems.each { m->
			m.surchargepaid = 0;
			m.interestpaid = 0;
			m.discounted = 0;
			m.total = m.principalpaid;
		}
		billitems.sort{ it.sortindex };

		//summarize items so we can store it in cash receipt
		def g = billitems.groupBy{ it.item }; 
		
		def receiptitems = []
		g.each { k,v->
			receiptitems << [item:k, amount:v.sum{it.total}]; 				
		}

		return [billitems: billitems, receiptitems: receiptitems ];
	}

}