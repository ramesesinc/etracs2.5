import com.rameses.annotations.*
import com.rameses.common.*;
import com.rameses.util.*
import com.rameses.services.extended.*


class RPTLedgerService
{
    @Env
    def env

    @ActiveDB('rptbill')
    def billdb 

    @ActiveDB('rptledger') 
    def em

    @Service('RPTUtil')
    def util

    @Service('Var')
    def var 

    @Service('DateService')
    def dtSvc

    @Service('NumberService')
    def numSvc

    @Service('FAASService')
    def faasSvc 

    @Service('PropertyClassificationService')
    def pcSvc 

    @Service('RPTBillingService')
    def billingSvc


    def SCHEMA_LEDGER   = 'rptledger'
    def SCHEMA_FAAS     = 'ledgerfaas'
    def SCHEMA_ITEM     = 'item'
    def SCHEMA_QTRLYITEM = 'qtrlyitem'
    def SCHEMA_CAPTUREPMT = 'capturepayment'

    def STATE_PENDING   = 'PENDING'
    def STATE_APPROVED  = 'APPROVED'
    def STATE_CANCELLED = 'CANCELLED'
    def STATE_OPEN      = 'OPEN'
    def STATE_CLOSED    = 'CLOSED'


    @ProxyMethod
    public def openLedger( ledger ) {
        ledger = em.findById(ledger)
        if (!ledger) throw new Exception('Ledger does not exists.')
        ledger.firstqtrpaidontime = util.toBoolean(ledger.firstqtrpaidontime, true)
        ledger.qtrlypaymentavailed = util.toBoolean(ledger.qtrlypaymentavailed, true)
        ledger.qtrlypaymentpaidontime = util.toBoolean(ledger.qtrlypaymentpaidontime, true)

        ledger.faases = getLedgerFaases(ledger.objid)
        return ledger 
    }

    @ProxyMethod
    public def createLedger( ledger ) {
        ledger.advancebill = false;
        em.create(ledger)
        ledger.faases.each{ ledgerfaas ->
            saveLedgerFaas(ledgerfaas)
        }
    }


    @ProxyMethod
    public def updateLedger( ledger ) {
        ledger.advancebill = false;
        em.update(ledger)    
        return ledger 
    }

    @ProxyMethod
    public void updateState(ledger){
        em.updateState(ledger)
    }

    
    @ProxyMethod
    public def saveLedgerFaas(ledgerfaas){
        em.save(ledgerfaas, SCHEMA_FAAS)
        return ledgerfaas 
    }

    @ProxyMethod
    public def removeLedgerFaas( ledgerfaas ) {
        em.delete(ledgerfaas, SCHEMA_FAAS)    
    }


    @ProxyMethod
    public def createLedgerItem( item ) {
        item.forpayment = util.toBoolean(item.forpayment, false)
        item.partial = util.toBoolean(item.partial, false)
        em.create(item, SCHEMA_ITEM)
        return item 
    }

    @ProxyMethod
    public def openLedgerItem( item ) {
        item = em.read(item, SCHEMA_ITEM)
        if (item){
            item.year = util.toInteger(item.year)
            item.forpayment = util.toBoolean(item.forpayment, false)
            item.qtrly = util.toBoolean(item.qtrly, false)
            item.partial = util.toBoolean(item.partial, false)
        }
        return item
    }

    @ProxyMethod
    public def updateLedgerItem( item ) {
        item.year = util.toInteger(item.year)
        item.forpayment = util.toBoolean(item.forpayment, false)
        item.partial = util.toBoolean(item.partial, false)
        em.update(item, SCHEMA_ITEM)
    }

    @ProxyMethod
    public def openLedgerItemQuarterly( item ) {
        item = em.read(item, SCHEMA_QTRLYITEM)
        if (item){
            item.year = util.toInteger(item.year)
            item.qtr = util.toInteger(item.qtr)
            item.forpayment = util.toBoolean(item.forpayment, false)
            item.partial = util.toBoolean(item.partial, false)
        }
        return item 
    }

    @ProxyMethod
    public def updateLedgerItemQuarterly( item ) {
        item.year = util.toInteger(item.year)
        item.qtr = util.toInteger(item.qtr)
        item.forpayment = util.toBoolean(item.forpayment, false)
        item.partial = util.toBoolean(item.partial, false)
        em.update(item, SCHEMA_QTRLYITEM)
    }

    @ProxyMethod
    public def updateLedgerItemAccountInfo( item ) {
        def params =[
            rptledgeritemid     : item.rptledgeritemid,
            basicacctid         : item.basicacct.objid,
            basicintacctid      : item.basicintacct.objid,
            sefacctid           : item.sefacct.objid,
            sefintacctid        : item.sefintacct.objid,
            firecodeacctid      : item.firecodeacct.objid,
        ]
        em.updateLedgerItemAccountInfo(params)
    }

    @ProxyMethod
    public def approveLedger( ledger) {
        ledger = openLedger(ledger)
        if (ledger.state == STATE_APPROVED )
            throw new Exception('Ledger has already been approved.')
        if (ledger.state == STATE_CANCELLED)
            throw new Exception('Ledger has already been cancelled.')

        def firstfaas = ledger.faases[0]
        def lastfaas = ledger.faases.last()
        ledger.state            =  STATE_APPROVED
        ledger.lastyearpaid     = (firstfaas.fromqtr == 1 ? firstfaas.fromyear - 1 : firstfaas.fromyear)
        ledger.lastqtrpaid      = (firstfaas.fromqtr == 1 ?  4 : firstfaas.fromqtr - 1)
        ledger.lastitemyear     = (lastfaas.toyear == 0 ? dtSvc.serverYear  : lastfaas.toyear )
        ledger.nextbilldate     = null
        ledger.advancebill      = false;
        em.update(ledger)
        
        ledger.faases.each{  
            it.state = ledger.state 
            em.approveLedgerFaas(it)
            postLedgerItems(it)
        }
        // billingSvc.generateBillByLedgerId(ledger.objid)
        return ledger;
    }

    @ProxyMethod
    public void checkLedgerBalance(faasid){
        def ledger = em.findApprovedLedgerByFaasId([faasid:faasid])
        if (!ledger)
            throw new Exception('Ledger does not exist or has already been deleted.')
            
        if (util.isTrue(ledger.taxable)) {
            if ( ledger.lastyearpaid < dtSvc.serverYear || (ledger.lastyearpaid == dtSvc.serverYear && ledger.lastqtrpaid < 4))
                throw new Exception('Ledger has not yet been fully paid.')    
        }
        else {
            em.updateLastYearQtrPaid([toyear:dtSvc.serverYear, toqtr:4, rptledgerid:ledger.objid])
        }
    }

    @ProxyMethod
    public void clearNextBillDateByLedger( ledgerid ) {
        em.clearNextBillDateByLedger([objid:ledgerid])
    }

    @ProxyMethod
    public void clearNextBillDate() {
        em.clearNextBillDate([:])
    }


    @ProxyMethod
    public def getLedgerByFaasId( faasid ) {
        def ledger = em.findLedgerByFaasId([faasid:faasid])
        if (!ledger) throw new Exception('Ledger does not exist or has already been deleted.')
        ledger.firstqtrpaidontime = util.toBoolean(ledger.firstqtrpaidontime, false)
        ledger.qtrlypaymentavailed = util.toBoolean(ledger.qtrlypaymentavailed, false)
        ledger.qtrlypaymentpaidontime = util.toBoolean(ledger.qtrlypaymentpaidontime, false )
        return ledger
    }


    @ProxyMethod
    public def getLedgerFaases(ledgerid){
        return em.getLedgerFaases([rptledgerid:ledgerid]).each {
                        it.taxable = util.toBoolean(it.taxable, true)
                        it.backtax = util.toBoolean(it.backtax, false)
                        it.systemcreated = util.toBoolean(it.systemcreated, true)
                    }
    }


    @ProxyMethod
    public def getLedgerItems(ledgerid){
        return em.getLedgerItems([rptledgerid:ledgerid])
    }


    @ProxyMethod
    public def getLedgerCredits(ledgerid) {
        return em.getLedgerCredits([rptledgerid:ledgerid])
    }


    @ProxyMethod
    public def getTxnTypes(){
        return faasSvc.getTxnTypes();
    }

    @ProxyMethod
    public def getClassifications(){
        return pcSvc.getClassifications([:])
    }


    @ProxyMethod
    public def postLedgerFaas( ledgerfaas ) {
        def ledgerfaases = getLedgerFaases(ledgerfaas.rptledgerid)
        def latestledgerfaas = ledgerfaases.find{it.toyear == 0}
        if (latestledgerfaas) {
            latestledgerfaas.toyear = (ledgerfaas.fromqtr == 1 ? ledgerfaas.fromyear - 1 : ledgerfaas.fromyear)
            latestledgerfaas.toqtr = (ledgerfaas.fromqtr == 1 ? 4 : ledgerfaas.fromqtr - 1)
            saveLedgerFaas(latestledgerfaas)
        }
        saveLedgerFaas(ledgerfaas)
    }


    @ProxyMethod
    public void postCapturedPayment( payment ) {
        payment.dtposted = dtSvc.serverDate 
        payment.postedby = env.NAME
        payment.postedbytitle = env.JOBTITLE
        def len = payment.paidby.name.length()
        if (len > 100 ) len = 100
        payment.paidby_name = payment.paidby.name
        payment.paidby_address = payment.paidby.address
        payment.paidby = payment.paidby.name.substring(0,len)
        em.create(payment, SCHEMA_CAPTUREPMT)

        em.updateLastYearQtrPaid(payment)    
        
        payment.origtoqtr = payment.toqtr

        payment.fromyear.upto(payment.toyear){ yr ->
            def item = em.findLedgerItemByYear([rptledgerid:payment.rptledgerid, year:yr])
            payment.paidyear = yr 
            payment.toqtr = payment.origtoqtr

            def bill = [rptledgerid:payment.rptledgerid, billtoyear:yr, insertqtrly:1, forpayment:0]

            if (item.qtrly == 1 && yr == payment.fromyear ){
                payment.toqtr = (payment.fromyear == payment.toyear ? payment.toqtr : 4)
                em.closePaidQtrlyLedgerItemByYear(payment)
                em.updateLedgerItemQuarterlyPaidInfo(payment)
            }
            else if (item.qtrly == 1 && yr == payment.toyear ){
                payment.toqtr = payment.origtoqtr
                em.closePaidQtrlyLedgerItemByYear(payment)
                em.updateLedgerItemQuarterlyPaidInfo(payment)
            }
            else if ( item.qtrly == 0 && yr == payment.fromyear && payment.fromyear == payment.toyear && ( payment.fromqtr != 1 || payment.toqtr != 4  )) {
                billingSvc.insertQtrlyLedgerItems(bill, [objid:payment.rptledgerid])
                em.closePaidQtrlyLedgerItemByYear(payment)
                em.updateLedgerItemQuarterlyPaidInfo(payment)
            }
            else if ( item.qtrly == 0 && yr == payment.toyear && ( payment.toqtr != 4 )) {
                billingSvc.insertQtrlyLedgerItems(bill, [objid:payment.rptledgerid])
                em.closePaidQtrlyLedgerItemByYear(payment)
                em.updateLedgerItemQuarterlyPaidInfo(payment)
            }
            else {
                em.closePaidLedgerItemByYear(payment)
            }
        }
    }

    void postLedgerItems(ledgerfaas){
        def pdate = dtSvc.parseCurrentDate()
        ledgerfaas.toyear  = (ledgerfaas.toyear == 0 ? pdate.year : ledgerfaas.toyear)
        // def qtrlyPrevYears = util.toBoolean(var.rptledger_previous_year_computed_as_quarterly, false)
        if (ledgerfaas.fromyear <= ledgerfaas.toyear ){
            ledgerfaas.fromyear.upto(ledgerfaas.toyear){ yr ->
                doPostLedgerItems(ledgerfaas.rptledgerid, ledgerfaas, yr)
            }
        }
    }

    void doPostLedgerItems(rptledgerid, ledgerfaas, yr){
        postYearlyItems(ledgerfaas, yr)
        if ( yr >= dtSvc.serverYear  ){
            billdb.insertQtrlyLedgerItems([rptledgerid:rptledgerid, billtoyear:yr, forpayment:0])
            billdb.setLedgerItemQtrlyFlag([rptledgerid:rptledgerid, billtoyear:yr, forpayment:0])
        }
    }

    void postYearlyItems(ledgerfaas, yr){
        println 'posting yearly item ' + ledgerfaas.objid + ' === ' + yr 
        createLedgerItem(doCreateLedgerItem(ledgerfaas, yr, 0))
    }

    @ProxyMethod
    public def insertLedgerItems(ledger, fromyear, toyear){
        def curryear = dtSvc.serverYear 
        if( fromyear <= toyear) {
            fromyear.upto(toyear){yr -> 
                def ledgerfaas = em.findLedgerFaasByFaasId([rptledgerid:ledger.objid, faasid:ledger.faasid, yr:yr, curryear:curryear])
                if( ledgerfaas ){
                    doPostLedgerItems(ledgerfaas.rptledgerid, ledgerfaas, yr)
                    em.updateLedgerLastItemYear([objid:ledger.objid, lastitemyear:toyear])
                }
            }
        }
    }


    def doCreateLedgerItem(ledgerfaas, yr, qtr){
        return [
            objid               : util.generateId('RLI'),
            state               : STATE_OPEN,
            rptledgerid         : ledgerfaas.rptledgerid,
            rptledgerfaasid     : ledgerfaas.objid, 
            year                : yr, 
            qtr                 : qtr, 
            assessedvalue       : ledgerfaas.assessedvalue,
            basic               : 0.0,
            basicpaid           : 0.0,
            basicint            : 0.0,
            basicintpaid        : 0.0,
            basicintpartial     : 0.0,
            basicdisc           : 0.0,
            basicdisctaken      : 0.0,
            basicamnesty        : 0.0,
            basicintamnesty     : 0.0,
            basicamnestyapplied : 0.0,
            basicintamnestyapplied : 0.0,
            basiccredit         : 0.0,
            sef                 : 0.0,
            sefpaid             : 0.0,
            sefint              : 0.0,
            sefintpaid          : 0.0,
            sefintpartial       : 0.0,
            sefdisc             : 0.0,
            sefdisctaken        : 0.0,
            sefamnesty          : 0.0,
            sefintamnesty       : 0.0,
            sefamnestyapplied   : 0.0,
            sefintamnestyapplied : 0.0,
            sefcredit           : 0.0,
            firecode            : 0.0,
            firecodepaid        : 0.0,
            forpayment          : 0,
            partial             : 0,
            lastqtrpaid         : 0,
            qtrly               : false,
        ]
    }




    @ProxyMethod
    public def approveMigratedLedger( ledger) {
        ledger = openLedger(ledger)
        if (ledger.state == STATE_CANCELLED)
            throw new Exception('Ledger has already been cancelled.')

        if (ledger.faases){
            def firstfaas = ledger.faases[0]
            def lastfaas = ledger.faases.last()
            ledger.state            =  STATE_APPROVED
            ledger.lastyearpaid     = (firstfaas.fromqtr == 1 ? firstfaas.fromyear - 1 : firstfaas.fromyear)
            ledger.lastqtrpaid      = (firstfaas.fromqtr == 1 ?  4 : firstfaas.fromqtr - 1)
            ledger.lastitemyear     = (lastfaas.toyear == 0 ? dtSvc.serverYear  : lastfaas.toyear )
            ledger.nextbilldate     = null
            ledger.advancebill      = false;
            em.update(ledger)
            
            ledger.faases.each{  
                it.state = ledger.state 
                em.approveLedgerFaas(it)
                postLedgerItems(it)
            }
        }
        return ledger;
    }


    @ProxyMethod
    public void fixLedger( info ) {
        if (!info.objid) throw new Exception('Ledger ID is required.')
        if (!info.taxpayer) throw new Exception('Taxpayer is required.')

        info.rptledgerid = info.objid 
        info.lastitemyear = (info.lastqtrpaid == 4 ? info.lastyearpaid : info.lastyearpaid - 1)
        info.paidyear = info.lastyearpaid
        info.toyear = info.lastyearpaid
        info.toqtr = info.lastqtrpaid

        em.updateLedgerLastItemYear(info)
        em.deleteQuarterlyLedgerItem(info)
        em.deleteLedgerItem(info)            

        def bill = billingSvc.initBill()
        bill.loadbillitems = false
        bill.taxpayer = info.taxpayer
        bill.ledgerids.add(info.objid)
        billingSvc.generateBill( bill )

        if (info.lastqtrpaid != 4){
            if (info.lastyearpaid == dtSvc.serverYear){
                em.fixPaidQtrlyLedgerItemByYear(info)
            }
            else {
                //simulate qtrly payment for previous year
                bill.billtoyear = info.lastyearpaid
                bill.billtoqtr = 3
                billingSvc.generateBill( bill )
                em.fixPaidQtrlyLedgerItemByYear(info)
                em.updateLedgerItemLastQtrPaid(info)
            }
            if (info.basic > 0.0 || info.sef > 0.0){
                em.partialPaidQtrlyLedgerItemByYear(info)
            }
        }
        else if (info.basic > 0.0 || info.sef > 0.0){
            em.partialPaidLedgerItemByYear(info)
        }

        em.updateLastYearQtrPaid(info)
        //force recalc bill again
        billingSvc.forceRecalcBill(info.objid)
    }

    void validateFixPartial(info, item){
        println 'item -> ' + item 
        if (info.basic > item.basic )
            throw new Exception('Partial Basic must not exceed ' + numSvc.format('#,##0.00',item.basic) + '.')
        if (info.basicint > item.basicint )
            throw new Exception('Partial Basic Penalty must not exceed ' + numSvc.format('#,##0.00',item.basicint) + '.')

        if (info.sef > item.sef )
            throw new Exception('Partial SEF must not exceed ' + numSvc.format('#,##0.00',item.sef) + '.')
        if (info.sefint > item.sefint )
            throw new Exception('Partial SEF Penalty must not exceed ' + numSvc.format('#,##0.00',item.sefint) + '.')
    }

}

