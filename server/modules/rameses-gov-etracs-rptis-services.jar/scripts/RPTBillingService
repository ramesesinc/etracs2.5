import com.rameses.annotations.*;
import java.rmi.server.*;
import com.rameses.rules.common.*;
import com.rameses.util.*;


public class RPTBillingService
{
	@PersistenceContext('main')
	def em 

	@Service('RPTUtil')
	def util

	@Service('Var')
	def var 

	@Service('DateService')
	def dtSvc 

	@Service('NumberService')
	def numSvc

	@Service('RPTLedgerService')
	def ledgerSvc 

	@Resource("RuleService")
	def ruleSvc;

	def RULESET = 'rptbilling'
	def FACT_PACKAGE = 'rptbilling.'


	@ProxyMethod
	public def initBill(){
		def pdate = dtSvc.parseCurrentDate()
		return [
			billdate 			: null,
			billtoyear 			: pdate.year,
			billtoqtr			: 4,
			advancebill			: false,
			fullpayment    		: true,
            qtrlypaymentavailed : false, 
            advancepayment      : false,
            currentdate 		: pdate.date,
            ledgerids 			: [],
            ledgers 			: [],
		]
	}


	@ProxyMethod
	public def getOpenLedgerCount(bill){
		return getOpenLedgerByTaxpayerId(bill).count()
	}

	@ProxyMethod
	public def generateBillByLedgerId(ledgerid){
		def bill = initBill()
		bill.billdate = dtSvc.serverDate
		bill.ledgerids.add(ledgerid)
		return generateBill(bill)
	}

	/*---------------------------------------------------------------
	* Called by RPTBilling Task to recalculate and update the
	* taxes and penalties of the specified ledger
	---------------------------------------------------------------*/
	@ProxyMethod
	public void calculateBillByLedgerIdAsync(ledgerid){
		def bill = initBill()
		bill.billdate = dtSvc.serverDate
		bill.ledgerids.add(ledgerid)
		recalcBillItems(bill)
	}

	@ProxyMethod
	public def generateBill( bill ) {
		util.required('Bill To Year', bill.billtoyear)
		util.required('Bill To Qtr', bill.billtoqtr)

		if (bill.advancepayment){
			if (bill.billtoyear < dtSvc.serverYear )
				throw new Exception('Advance Year must be greater than current year.')
			bill.billdate = (bill.billdate ? dtSvc.parse('yyyy-MM-dd', bill.billdate) : dtSvc.serverDate)
		}
		else {
			bill.billdate = dtSvc.serverDate 
		}

		bill.expirydate = getExpiryDate(bill)

		bill.taxpayerid = bill.taxpayer?.objid 
		if (! bill.taxpayerid && ! bill.ledgerids)
			throw new Exception('Either a Taxpayer or Ledger to bill is required.')

		if (bill.advancebill && bill.billdate <= (dtSvc.serverDate - 1 ))
            throw new Exception('Advance Billing Date must be greater than current date.')
		
		recalcBillItems(bill)
		loadBillItems(bill)

		if (!bill.ledgers) 
			throw new Exception('There are no unpaid ledgers for payment.')

		return bill
	}

	
	def getExpiryDate(bill) {
		def dt = dtSvc.parseDate(bill.billdate,null);

		//check in database if there is qtr deadline overrides
		def qtr_deadline = em.sqlContext.createQuery('''
				select expirydate,expirytype from rptexpiry 
				where iqtr=$P{qtr} and iyear=$P{year}
				and expirydate >= $P{date}
				order by expirydate asc 
		''')
			.setParameters([qtr:dt.qtr, year:dt.year, date:dt.date])
			.singleResult;
		
		//check discount, interest overrides
		def expirydate = null;
		def expirytype = null;

		if( ! qtr_deadline ) {
			qtr_deadline = [
				expirydate : dtSvc.getQtrEndDate(dt.qtr, dt.year),
				expirytype : 'QTRDUEDATE',
			]
		}

		expirydate = qtr_deadline.expirydate;
		expirytype = qtr_deadline.expirytype;

		//check discount first
		if(expirytype?.equalsIgnoreCase("DISCOUNT")) {
			return qtr_deadline.expirydate;
		}
		
		//if there are arrears, expiry is first day of next month
		def years = bill.ledgers.items.year.flatten().unique()
		if (years.findAll{ util.toInteger(it) < dt.year}){
			return dtSvc.add(dtSvc.getMonthEndDate(dt.date), '1d')
		}

		//check for interest overrides
		if( expirytype?.equalsIgnoreCase("INTEREST")) {
			return qtr_deadline.expirydate;
		}
		
		if( qtr_deadline ) {
			return qtr_deadline.expirydate;
		}	
		else {
			return dtSvc.add(dtSvc.getMonthEndDate(dt.date), '1d')
		} 
	}


	@ProxyMethod
	public def computePartialPayment(ledger, payment ) {
		if (!ledger.items)
			throw new Exception('Items for payment are required.')
		if (payment == null || payment == 0)
			throw new Exception('Payment is required.')

		def paiditems = [] 

		ledger.items.each{
			if (payment > 0.0) {
				def amtdue = it.total
				if ( payment >= amtdue){
					payment -= amtdue 
				}
				else {
					//apply proportionally
					def basicpaymentrate  = numSvc.round(it.basicnet / (it.basicnet + it.sefnet))
					def basicpayment 	= numSvc.round(payment * basicpaymentrate)
					def sefpayment 		= payment - basicpayment 

					def basicintrate    = numSvc.round(it.basicint / it.basic)
					def basic           = numSvc.round(basicpayment / (1 + basicintrate))
					it.basicint         = basicpayment - basic 
					if (it.basicdisc == 0.0) {
						it.basic = basic 
					}
					else{
						it.basicdisc = numSvc.round(basic * basicdiscrate)
						it.basic     = basic + it.basicdisc 
					}
					it.basicdp 			= it.basicint - it.basicdisc 
					it.basicnet 		= it.basic + it.basicdp

					def sefintrate    = numSvc.round(it.sefint / it.sef)
					def sef           = numSvc.round(sefpayment / (1 + sefintrate))
					it.sefint         = sefpayment - sef 
					if (it.sefdisc == 0.0) {
						it.sef = sef 
					}
					else{
						it.sefdisc = numSvc.round(sef * sefdiscrate)
						it.sef     = sef + it.sefdisc 
					}
					it.sefdp 			= it.sefint - it.sefdisc 
					it.sefnet 		= it.sef + it.sefdp

					it.total 		= it.basicnet + it.sefnet 
					it.partialled 	= true
					payment = 0.0
				}
				paiditems += it 
			}
		}
		ledger.items = paiditems 
		summarizeLedgerInfo(ledger)
		ledger.partialled = true
		return ledger 
	}



	@ProxyMethod
	public def getLedgersToRecalc(count){
		return em.sqlContext.createNamedQuery('rptbill:getLedgersToRecalc')
				.setMaxResults(count)
				.setParameter('billdate', dtSvc.serverDate)
				.resultList
	}


	def phases = ['TAX', 'PENALTY', 'DISCOUNT']

	@ProxyMethod
	public void recalcBillItems(bill){
		bill.ledgers = getOpenLedgers(bill)
		if ( bill.ledgers) {
			def data = createFacts(bill)
			phases.each{phase ->
				ruleSvc.execute( RULESET, data.facts, data.globals, phase );
			}
			buildResult(bill, data)
			updateLedgerBillingInfo(bill)
		}
	}

	@Async
	@ProxyMethod
	public def recalcBillItemsAsync( bill ) {
		recalcBillItems(bill)	
	}

	def createFacts(bill){
		def pdate = dtSvc.parseCurrentDate()

		def map = [facts:[], globals:[:], ledgers:[]]
		map.facts << new DateBean(dtSvc.serverDate)

		//create rptledgerfact 
		bill.ledgers.each{ rl ->
			createAssessedValueFacts(map, rl)
			rl.items.each{
				resetAssessmentValues(it)
				def ledger = ruleSvc.createFact(RULESET, FACT_PACKAGE+'RPTLedgerFact')
				populateFactData(ledger, it)
				ledger.numberofmonthsfromqtr  = calculateNoOfMonthsFromQtr( pdate, ledger.year, ledger.qtr )
	            ledger.numberofmonthsfromjan  = calculateNoOfMonthsFromJan( pdate, ledger.year, ledger.qtr )
	            ledger.firstqtrpaidontime     = determineFirstQtrPaidOnTime( pdate, bill, it )
	            ledger.qtrlypaymentavailed    = determineQtrlyPaymentAvailed( bill, it )
				ledger.qtrlypaymentpaidontime = util.toBoolean(it.qtrlypaymentpaidontime, false )
	            ledger.fullpayment            = ( bill.billtoqtr == 4 && it.lastqtrpaid == 4 ? true : false )
	            ledger.advancepayment         = bill.advancepayment 
	            ledger.paidyear				  = pdate.year 
				map.facts << ledger 
				map.ledgers << ledger
			}
		}
		return map 
	}

	void createAssessedValueFacts(map, rl){
		def avyears = var.rptbilling_assessed_value_fact_years
		if ( !avyears ) return 
		avyears.split(',').each{ yr ->
			def ledgerfaas = em.sqlContext.createNamedQuery('rptbill:getLedgerFaasAV')
					.setParameter('rptledgerid', rl.objid)
					.setParameter('avyear', yr)
					.singleResult
			if (ledgerfaas){
				def avfact = ruleSvc.createFact(RULESET, FACT_PACKAGE+'AssessedValueFact')
				avfact.rptledgerid = rl.objid
				avfact.year  	   = util.toInteger(yr)
				avfact.assessedvalue  = numSvc.round(ledgerfaas.assessedvalue/4)
				map.facts << avfact 		
			}
		}

	}

	void resetAssessmentValues(item){
		item.basic = 0.0
		item.basicint = 0.0
		item.basicdisc = 0.0
		item.basiccredit = 0.0
		item.sef = 0.0
		item.sefint = 0.0
		item.sefdisc = 0.0
		item.sefcredit = 0.0
	}

	void populateFactData(target, sourceMap){
		sourceMap.keySet().each{
			try{
				target[it] = sourceMap[it]
			}
			catch(e){
				//ignore
			}
		}
	}

	void updateLedgerBillingInfo(bill){
		def ledgerinfo = [
			nextbilldate : bill.expirydate,
		]
		
		if ( bill.ledgerids && bill.ledgerids.size() > 0) {
			bill.ledgerids.each{
				ledgerinfo.ledgerid = it
				em.sqlContext.createNamedExecutor('rptbill:updateLedgerNextBillDate')
							.setParameters(ledgerinfo)
							.execute()
			}
		}
		else {
			ledgerinfo.taxpayerid = bill.taxpayerid 
			em.sqlContext.createNamedExecutor('rptbill:updateLedgerNextBillDateByTaxpayerId')
							.setParameters(ledgerinfo)
							.execute()
			println 'TODO: updateLedgerNextBillDateByPropertyPayer'
		}

		bill.ledgers.each{ ld ->
			ld.items.each{
				ledgerSvc.updateLedgerItem(it)
			}
		}
	}




	void loadBillItems(bill){
		def params = [
			billtoyear	: bill.billtoyear,
			billtoqtr   : bill.billtoqtr,
			taxpayerid  : bill.taxpayerid,
			currentyr   : dtSvc.serverYear,
		]

		bill.ledgers = []
		bill.ledgerids.each{
			bill.ledgers.add([objid:it])
		}

		if ( ! bill.ledgerids || bill.ledgerids.size() == 0) {
			bill.ledgers.addAll(
				em.sqlContext.createNamedQuery('rptbill:getBilledLedgersByTaxpayerId')
								.setParameters(params)
								.resultList
			)
			println 'TODO:getBillItemByPropertyPayer'
		}

		bill.ledgers.each{ ledger ->
			ledger.putAll(
				em.sqlContext.createNamedQuery('rptbill:getBilledLedgerInfoByLedgerId')
							.setParameter('ledgerid', ledger.objid)
							.singleResult 
			)
			
			params.ledgerid = ledger.objid

			if (util.toBoolean(bill.forprinting, false) == true ) {
				ledger.items = em.sqlContext.createNamedQuery('rptbill:getPreviousBilledItemsForPrinting')
								.setParameters(params)
								.resultList 
				ledger.items += em.sqlContext.createNamedQuery('rptbill:getCurrentYearBilledItemsForPrinting')
								.setParameters(params)
								.resultList 
			}
			else {
				ledger.items = em.sqlContext.createNamedQuery('rptbill:getBilledItemsByLedgerId')
								.setParameters(params)
								.resultList 	
			}

			summarizeLedgerInfo(ledger)
		}
		calcBillTotals(bill)
	}

	void summarizeLedgerInfo(ledger){
		ledger.basic		= util.sum(ledger.items, 'basic')
		ledger.basicdp		= util.sum(ledger.items, 'basicdp')
		ledger.basicnet		= util.sum(ledger.items, 'basicnet')
		ledger.sef			= util.sum(ledger.items, 'sef')
		ledger.sefdp		= util.sum(ledger.items, 'sefdp')
		ledger.sefnet		= util.sum(ledger.items, 'sefnet')
		ledger.total		= util.sum(ledger.items, 'total')
		if (ledger.items){
			ledger.toyear 		= ledger.items.last().year
			ledger.toqtr 		= (ledger.items.last().qtr == 0 ? 4 : ledger.items.last().qtr)
		}
		ledger.pay 			= true
		ledger.partialled   = false

	}

	void calcBillTotals(bill){
		//summarize totals
		bill.basic		= util.sum(bill.ledgers, 'basic')
		bill.basicdp	= util.sum(bill.ledgers, 'basicdp')
		bill.basicnet	= util.sum(bill.ledgers, 'basicnet')
		bill.sef		= util.sum(bill.ledgers, 'sef')
		bill.sefdp		= util.sum(bill.ledgers, 'sefdp')
		bill.sefnet		= util.sum(bill.ledgers, 'sefnet')
		bill.total		= util.sum(bill.ledgers, 'total')
		bill.grandtotal = util.sum(bill.ledgers, 'total')
	}


	def getOpenLedgerByTaxpayerId(bill){
		def ledgers = []
		ledgers +=  em.sqlContext.createNamedQuery('rptbill:getOpenLedgerByTaxpayerId')
							.setParameter('taxpayerid', bill.taxpayerid)
							.setParameter('billtoyear', bill.billtoyear)
							.resultList
		ledgers += getOpenLedgerItemByPropertyPayer(bill)
		return ledgers 
	}

	def getOpenLedgers(bill){
		def ledgers = []
		bill.ledgerids.each{
			ledgers.add([objid:it])
		}

		ledgers += getOpenLedgerByTaxpayerId(bill)

		ledgers.each{ ledger ->
			ledger.putAll(
				em.sqlContext.createNamedQuery('rptbill:getBilledLedgerInfoByLedgerId')
						.setParameter('ledgerid', ledger.objid)
						.singleResult
			)
			if (ledger.lastitemyear < bill.billtoyear ){
				ledgerSvc.insertLedgerItems(ledger, ledger.lastitemyear + 1, bill.billtoyear)
			}
			ledger.items = em.sqlContext.createNamedQuery('rptbill:getOpenLedgerItemByLedgerId')
							.setParameter('ledgerid', ledger.objid)
							.resultList.each{
								it.basic = it.basic - it.basicpaid
								it.sef = it.sef - it.sefpaid
							}
		}
		return ledgers
	}


	def getOpenLedgerItemByPropertyPayer(bill){
		println 'TODO: getOpenLedgerItemByPropertyPayer'
		return []
	}


	int calculateNoOfMonthsFromQtr(pdate, year, qtr) {
		int currYear = pdate.year
		int currMonth = pdate.month
		qtr = ( qtr == 0 ? 1 : qtr )
		if(year < currYear) {
			return ((currYear - year) * 12 - (3 * (qtr-1))) + currMonth 
		}
		else {
			int nm = currMonth - (3 * (qtr-1))
			return nm < 0 ? 0 : nm
		}
	}
	
	int calculateNoOfMonthsFromJan(pdate, year, qtr) {
		int currYear = pdate.year
		int currMonth = pdate.month
		if(year < currYear) {
			return ( currYear - year ) * 12 + currMonth
		}
		else {
			return currMonth
		}
	}

	boolean determineFirstQtrPaidOnTime( pdate, bill, item ) {
        if( pdate.qtr == 1 && item.lastyearpaid == pdate.year -1 && item.lastqtrpaid == 4 ) return true 
        if( item.lastyearpaid == pdate.year && item.lastqtrpaid >= 1 && pdate.qtr == 1 ) return true
        return item.firstqtrpaidontime
    }

    boolean determineQtrlyPaymentAvailed( bill, item ) {
        if( bill.billtoqtr != 4 ) return true 
        if( bill.billtoqtr == 4 && item.lastqtrpaid != 4 ) return true 
        return false 
    }
	
	void buildResult(bill, data){
		bill.ledgers.each{bl ->
			bl.items.each{ item ->
				def ledger = data.ledgers.find{it.objid == item.objid}
				if (ledger){
					item.basic = numSvc.round(ledger.basic)
					item.basicint = numSvc.round(ledger.basicint)
					item.basicdisc = numSvc.round(ledger.basicdisc)
					item.sef = numSvc.round(ledger.sef)
					item.sefint = numSvc.round(ledger.sefint)
					item.sefdisc = numSvc.round(ledger.sefdisc)
					item.paidyear = ledger.paidyear 
					item.basicacctid = ledger.basicacctid
					item.basicintacctid = ledger.basicintacctid
					item.sefacctid = ledger.sefacctid
					item.sefintacctid = ledger.sefintacctid
					item.revtype = ledger.revtype 
				}
			}
		}
	}

}
	