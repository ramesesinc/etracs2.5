import com.rameses.annotations.*;
import java.rmi.server.*;
import com.rameses.rules.common.*;
import com.rameses.util.*;
import com.rameses.services.extended.*;


public class RPTBillingService
{
	@ActiveDB('rptbill')
	def em 

	@ActiveDB("rule")
	def ruleDB;


	@Service('RPTUtil')
	def util

	@Service('Var')
	def var 

	@Service('DateService')
	def dtSvc 

	@Service('NumberService')
	def numSvc

	@Service('RPTLedgerService')
	def ledgerSvc 

	@Resource("RuleService")
	def ruleSvc;

	def RULESET = 'rptbilling'
	def FACT_PACKAGE = 'rptbilling.'
	def MAX_ADVANCE_YEARS = 3 
	
	def SCHEMA_BILL_ITEM = 'billitem'

	@ProxyMethod
	public def initBill(ledgerid){
		def pdate = dtSvc.parseCurrentDate()
		return [
			billdate 			: pdate.date,
			billtoyear 			: pdate.year,
			billtoqtr			: 4,
			advancebill			: false,
			fullpayment    		: true,
            qtrlypaymentavailed : false, 
            advancepayment      : false,
            currentdate 		: pdate.date,
            cy 					: pdate.year,
            rptledgerid 		: ledgerid,
		]
	}


	@ProxyMethod
	public def loadProperties(bill){
		bill.billdate = dtSvc.serverDate
		if (!bill.taxpayer) throw new Exception('Taxpayer is required.')
		bill.taxpayerid = bill.taxpayer.objid
		return  em.getBilledLedgers(buildParams(bill))
	}


	@ProxyMethod
	public def generateBillByLedgerId(ledgerid){
		def bill = initBill(ledgerid)
		bill.billdate = dtSvc.serverDate
		return generateBill(bill)
	}

	/*---------------------------------------------------------------
	* Called by RPTBilling Task to recalculate and update the
	* taxes and penalties of the specified ledger
	---------------------------------------------------------------*/
	@ProxyMethod
	public void calculateBillByLedgerIdAsync(ledgerid){
		def bill = initBill(ledgerid)
		bill.billdate = dtSvc.serverDate
		recalcBillItems(bill)
	}

	@ProxyMethod
	public void forceRecalcBill( ledgerid ) {
		util.required('Ledger ID', ledgerid)
		em.clearLedgerBillingInfoFlags([filters:'rl.objid = $P{objid}', objid:ledgerid])
		calculateBillByLedgerIdAsync(ledgerid)
	}


	/*==================================================================
	** - Billing is generated by Ledger
	** - clear billitems 
	** - generate bill starting from (lastyearpaid, lastqtrpaid) to billtoyear
	** - save billitems ( yr >= cy must be save as qtrly)
	===================================================================*/
	@ProxyMethod
	public def generateBill( bill ) {
		util.required('Bill To Year', bill.billtoyear)
		util.required('Bill To Qtr', bill.billtoqtr)

		def maxbilltoyear = dtSvc.serverYear + MAX_ADVANCE_YEARS
		if (bill.billtoyear > maxbilltoyear){
			throw new Exception('Bill To Year must not exceed year ' +  maxbilltoyear + '.')
		}

		if (bill.billdate == null) 
			bill.billdate = dtSvc.serverDate
		else
			bill.billdate = dtSvc.parse('yyyy-MM-dd', bill.billdate)

		if (bill.advancepayment){
			if (bill.billtoyear < dtSvc.serverYear )
				throw new Exception('Advance Year must be greater than current year.')
		}
		else if (bill.advancebill){
			if ( bill.billdate < bill.currentdate )
				throw new Exception('Advance Billing Date must be greater than current date.')
		}
		
		bill.taxpayerid = bill.taxpayer?.objid 
		if (! bill.rptledgerid)
			throw new Exception('Ledger to bill is required.')

		if (bill.advancebill && bill.billdate <= (dtSvc.serverDate - 1 ))
            throw new Exception('Advance Billing Date must be greater than current date.')

        bill.ledger = em.findOpenLedgerById(bill)
        if (!bill.ledger) throw new Exception('Ledger if fully paid.')

        if (bill.ledger.recalcbill == 1 ){
        	println 'Recalculating ledger -> ' + bill.ledger.tdno 
        	clearBillItems(bill)
	        def data = executeRules(bill)
	        saveBillItems(bill, data)
	        bill.expirydate = getExpiryDate(bill)
	        bill.validuntil = dtSvc.add(bill.expirydate, '-1d')
	        em.updateLedgerNextBillDate(buildParams(bill))
        }
		return bill
	}


	void clearBillItems(bill){
		em.clearBillItems(bill)
	}

	void saveBillItems(bill, data){
		data.ledgers.each{
			em.create(it, SCHEMA_BILL_ITEM)
		}
		//apply partial
		if (bill.ledger.partialled == 1) {
			em.applyPartialPayment(bill.ledger)
		}

	}


	/*========================================================
	*
	* NOTE: billing is now by ledger
	*
	========================================================*/
	@ProxyMethod
	public def buildParams(bill){
		def cdate = dtSvc.parseCurrentDate()
		def pdate = dtSvc.parseDate(bill.billdate, null)
		def params = [
			rptledgerid : bill.rptledgerid,
			taxpayerid : bill.taxpayerid,
			billtoyear  : bill.billtoyear, 
			billtoqtr   : bill.billtoqtr,
			toyear  	: bill.billtoyear, 
			toqtr   	: bill.billtoqtr, 
			currdate    : cdate.date,
			currentyr   : cdate.year,
			currentqtr  : cdate.qtr,
			nextbilldate : bill.expirydate,
			billdate   : pdate.date,
			billyear   : pdate.year,
			billqtr    : pdate.qtr,
			rputype    : bill.rputype, 
			forpayment : 0,
		]
		if (bill.rptledgerid) {
			params.filters = ' rl.objid = $P{rptledgerid}'
		}
		else {
			params.filters = ' f.taxpayer_objid = $P{taxpayerid} '
		}
		if (bill.rputype ){
			params.filters += ' AND r.rputype = $P{rputype} '
		}

		if (bill.barangay){
			params.barangayid = bill.barangay.objid 
			params.filters += ' AND rp.barangayid = $P{barangayid}'
		}
		return params
	}



	/*============================================================================
	**
	** BILLING RULES SUPPORT
	**
	============================================================================**/

	@ProxyMethod
	public def executeRules(bill){
		def data = createFacts(bill)
		def actions = buildActions(bill, data)
		def grps = ruleDB.getRulegroups( [ruleset: RULESET] );
		grps.each{g ->
			ruleSvc.execute( RULESET, data.facts, actions, g.name);
		}
		return data 
	}

	def buildActions(bill, data){
		def actions = new RuleAction();
		actions.addCommand('calc-basic', new CalcBasic(ledgers:data.ledgers))
		actions.addCommand('calc-basicint', new CalcBasicInterest(ledgers:data.ledgers))
		actions.addCommand('calc-basicdisc', new CalcBasicDiscount(ledgers:data.ledgers))
		actions.addCommand('calc-basic-amnesty', new CalcBasicAmnesty(ledgers:data.ledgers))
		actions.addCommand('calc-basicint-amnesty', new CalcBasicIntAmnesty(ledgers:data.ledgers))

		actions.addCommand('calc-sef', new CalcSEF(ledgers:data.ledgers))
		actions.addCommand('calc-sefint', new CalcSEFInterest(ledgers:data.ledgers))
		actions.addCommand('calc-sefdisc', new CalcSEFDiscount(ledgers:data.ledgers))
		actions.addCommand('calc-sef-amnesty', new CalcSEFAmnesty(ledgers:data.ledgers))
		actions.addCommand('calc-sefint-amnesty', new CalcSEFIntAmnesty(ledgers:data.ledgers))

		actions.addCommand('calc-firecode', new CalcFireCode(ledgers:data.ledgers))
		return actions 
	}

	def createFacts(bill){
		def data = [facts:[], ledgers:[]]
		data.facts << new CurrentDate(dtSvc.serverDate)
		data.facts << new EffectiveDate(dtSvc.serverDate)

		//create RPTLedgerFacts
		bill.items = []
		def ledgerfaases = []
		if (bill.noledger == true)
			ledgerfaases << bill.ledger 
		else 
		 	ledgerfaases = em.getLedgerFaases(bill)

		def cy = dtSvc.serverYear
		bill.ledger.fromyear.upto(bill.billtoyear){ yr ->
			if (yr >= cy){
				createQtrlyLedgerFacts(data, bill, ledgerfaases, yr)
			}
			else{
				createYearlyLedgerFact(data, bill, ledgerfaases, yr)
			}
			data.facts << createAssessedValueFacts(data, bill.ledger, ledgerfaases)
		}
		return data 
	}


	void createQtrlyLedgerFacts(data, bill, ledgerfaases, yr){
		def ledgerfaas = ledgerfaases.find{ yr >= it.fromyear && ( yr <= it.toyear || it.toyear == 0) }
		if (!ledgerfaas){
			def xyr = yr + 1
			ledgerfaas = ledgerfaases.find{ xyr >= it.fromyear && ( xyr <= it.toyear || it.toyear == 0) }
		}
		if (!ledgerfaas) 
			throw new Exception('Ledger FAAS ' + bill.ledger.tdno +  ' for year ' + yr + ' is not defined.\nVerify RPT Ledger faas history record.')

		def qtrlyav  = numSvc.round( ledgerfaas.assessedvalue / 4)
		def fourthqtrav = ledgerfaas.assessedvalue - numSvc.round((qtrlyav * 3))

		def fromqtr = (yr == bill.ledger.fromyear ? bill.ledger.fromqtr : 1 )
		def toqtr = (yr == bill.billtoyear ? bill.billtoqtr : 4)

		fromqtr.upto(toqtr){qtr ->
			def av = qtrlyav
			if (qtr == 4) av = fourthqtrav
			def ledger = createRPTLedgerData(bill, ledgerfaas, yr, qtr, qtr, qtr, av)
			def ledgerfact = createLedgerFact(ledger)
			data.ledgers << ledger 
			data.facts << ledgerfact 
		}
	}


	void createYearlyLedgerFact(data, bill, ledgerfaases, yr){
		def ledgerfaas = ledgerfaases.find{ yr >= it.fromyear && ( yr <= it.toyear || it.toyear == 0) }
		if (!ledgerfaas){
			def xyr = yr + 1
			ledgerfaas = ledgerfaases.find{ xyr >= it.fromyear && ( xyr <= it.toyear || it.toyear == 0) }
		}
		if (!ledgerfaas) 
			throw new Exception('Ledger FAAS ' + bill.ledger.tdno +  ' for year ' + yr + ' is not defined.\nVerify RPT Ledger faas history record.')

		def qtrlyav = numSvc.round( ledgerfaas.assessedvalue / 4)
		def av      = ledgerfaas.assessedvalue

		def fromqtr = (yr == bill.ledger.fromyear ? bill.ledger.fromqtr : 1 )
		def toqtr = (yr == bill.billtoyear ? bill.billtoqtr : 4)

		if (fromqtr != 1 || toqtr != 4)
			av = qtrlyav * (toqtr - fromqtr + 1)

		def ledger = createRPTLedgerData(bill, ledgerfaas, yr, 0, fromqtr, toqtr, av)
		def ledgerfact = createLedgerFact(ledger)
		data.ledgers << ledger 
		data.facts << ledgerfact 
	}


	def createRPTLedgerData(bill, ledgerfaas, yr, qtr, fromqtr, toqtr, av){
		def pdate = dtSvc.parseDate(bill.billdate, null)
		def ledger = [:]
		resetAssessmentValues(ledger)
		ledger.objid				= 'BI' + new java.rmi.server.UID()
		ledger.rptledgerid		= bill.ledger.objid
		ledger.rptledgerfaasid  = ledgerfaas.objid
		ledger.tdno				= ledgerfaas.tdno
		ledger.year 			= yr 
		ledger.qtr 				= qtr
		ledger.fromqtr 			= fromqtr
		ledger.toqtr 			= toqtr
		ledger.originalav 		= ledgerfaas.assessedvalue 
		ledger.assessedvalue	= ledgerfaas.assessedvalue 
		ledger.av 				= av
		ledger.qtrlyav 				= av
		ledger.txntype 			= ledgerfaas.txntype.objid
		ledger.rputype 			= bill.ledger.rputype 
		ledger.classification 	= ledgerfaas.classification.objid 
		ledger.actualuse 			= ledgerfaas.actualuse.objid 
		ledger.numberofmonthsfromqtr  = calculateNoOfMonthsFromQtr( pdate, yr, qtr )
        ledger.numberofmonthsfromjan  = calculateNoOfMonthsFromJan( pdate, yr, qtr )
        ledger.firstqtrpaidontime     = determineFirstQtrPaidOnTime( pdate, bill, bill.ledger )
        ledger.qtrlypaymentavailed    = determineQtrlyPaymentAvailed( bill, bill.ledger)
		ledger.qtrlypaymentpaidontime = util.toBoolean(bill.ledger.qtrlypaymentpaidontime, false )
        ledger.fullpayment            = determineFullPayment(pdate, bill, bill.ledger, ledger) 
        ledger.advancepayment         = bill.advancepayment 
		ledger.backtax				= ledgerfaas.backtax 
		return ledger 
	}

	def createLedgerFact(ledger){
		def ledgerfact = ruleSvc.createFact(RULESET, FACT_PACKAGE+'RPTLedgerFact')
		populateFactData(ledgerfact, ledger)
		return ledgerfact 
	}

	void populateFactData(target, sourceMap){
		sourceMap.keySet().each{
			try{
				target[it] = sourceMap[it]
			}
			catch(e){
				//ignore
			}
		}
	}

	void createAssessedValueFacts(map, rl, ledgerfaases){
		def avyears = var.rptbilling_assessed_value_fact_years
		if ( !avyears ) return 
		avyears.split(',').each{ yr ->
			yr = util.toInteger(yr)
			def ledgerfaas = ledgerfaases.find{ yr >= it.fromyear && ( yr <= it.toyear || it.toyear == 0) }
			if (ledgerfaas){
				def avfact = ruleSvc.createFact(RULESET, FACT_PACKAGE+'AssessedValueFact')
				avfact.rptledgerid = rl.objid
				avfact.year  	   = util.toInteger(yr)
				avfact.assessedvalue  = numSvc.round(ledgerfaas.assessedvalue)
				map.facts << avfact 		
			}
		}
	}


	void resetAssessmentValues(item){
		item.basic = 0.0
		item.basicpaid = 0.0
		item.basicint = 0.0
		item.basicintpaid = 0.0
		item.basicintpartial = 0.0
		item.basicdisc = 0.0
		item.basicdisctaken = 0.0
		item.basicamnesty = 0.0
		item.basicintamnesty = 0.0
		item.basiccredit = 0.0
		item.sef = 0.0
		item.sefpaid = 0.0
		item.sefint = 0.0
		item.sefintpaid = 0.0
		item.sefintpartial = 0.0
		item.sefdisc = 0.0
		item.sefdisctaken = 0.0
		item.sefamnesty = 0.0
		item.sefintamnesty = 0.0
		item.sefcredit = 0.0
		item.firecode = 0.0
		item.firecodepaid = 0.0
		item.amnestyinfo = 0.0
		item.forpayment = false
		item.partial = false
		item.partialbasic = 0.0
		item.partialbasicint = 0.0
		item.partialbasicdisc = 0.0
		item.partialsef = 0.0
		item.partialsefint = 0.0
		item.partialsefdisc = 0.0
	}

	int calculateNoOfMonthsFromQtr(pdate, year, qtr) {
		if (qtr == null || qtr == 0) qtr = 1 
		int currYear = pdate.year
		int currMonth = pdate.month
		qtr = ( qtr == 0 ? 1 : qtr )
		if(year < currYear) {
			return ((currYear - year) * 12 - (3 * (qtr-1))) + currMonth 
		}
		else {
			int nm = currMonth - (3 * (qtr-1))
			return nm < 0 ? 0 : nm
		}
	}
	
	int calculateNoOfMonthsFromJan(pdate, year, qtr) {
		int currYear = pdate.year
		int currMonth = pdate.month
		int nmon = 0;
		if(year < currYear) {
			nmon = ( currYear - year ) * 12 + currMonth
		}
		else {
			nmon = currMonth
		}
		return nmon 
	}

	boolean determineFirstQtrPaidOnTime( pdate, bill, item ) {
        if( pdate.qtr == 1 && item.lastyearpaid == pdate.year -1 && item.lastqtrpaid == 4 ) return true 
        if( item.lastyearpaid == pdate.year && item.lastqtrpaid >= 1 && pdate.qtr == 1 ) return true
        return item.firstqtrpaidontime
    }

    boolean determineQtrlyPaymentAvailed( bill, item ) {
        if( bill.billtoqtr != 4 ) return true 
        if( bill.billtoqtr == 4 && item.lastqtrpaid != 4 ) return true 
        return false 
    }

    boolean determineFullPayment(pdate, bill, rl, item) {
    	def fullpayment = false

    	if (item.year > pdate.year && item.year < bill.billtoyear) 
    		fullpayment = true
    	else if (item.year > pdate.year && item.year == bill.billtoyear &&  bill.billtoqtr == 4)
    		fullpayment = true 
    	else if (item.year == pdate.year && rl.lastyearpaid == 4 &&  bill.billtoqtr == 4)
    		fullpayment = true 

    	return fullpayment
    }



	def getExpiryDate(bill) {
		def dt = dtSvc.parseDate(bill.billdate,null);

		//check in database if there is qtr deadline overrides
		def qtr_deadline = em.findExpiry([qtr:dt.qtr, year:dt.year, date:dt.date])
		
		//check discount, interest overrides
		def expirydate = null;
		def expirytype = null;

		if( ! qtr_deadline ) {
			qtr_deadline = [
				expirydate : dtSvc.getQtrEndDate(dt.qtr, dt.year),
				expirytype : 'QTRDUEDATE',
			]
		}

		expirydate = dtSvc.add(qtr_deadline.expirydate, '1d');
		expirytype = qtr_deadline.expirytype;

		//check discount first
		if(expirytype?.equalsIgnoreCase("DISCOUNT")) {
			return qtr_deadline.expirydate;
		}
		
		//if there are arrears, expiry is first day of next month
		if (bill.ledger.lastyearpaid < dt.year){
			return dtSvc.add(dtSvc.getMonthEndDate(dt.date), '1d')
		}

		//check for interest overrides
		if( expirytype?.equalsIgnoreCase("INTEREST")) {
			return qtr_deadline.expirydate;
		}
		
		if( qtr_deadline ) {
			return qtr_deadline.expirydate;
		}	
		else {
			return dtSvc.add(dtSvc.getMonthEndDate(dt.date), '1d')
		} 
	}




	@ProxyMethod
	public def computePartialPayment( ledger, payment  ) {
		def partial = payment 
		if (payment == null || payment == 0)
			throw new Exception('Partial Payment is required.')

		def paiditems = em.getFullyPaidItems(['rptledgerid':ledger.rptledgerid])
		def idx = 0
		def pitem = null 
		def totalbasic = 0.0
		def totalsef = 0.0
		def partialinfo = [:]

		for(; idx < paiditems.size(); idx++)
		{
			if (payment == 0.0 ) break;

			pitem = paiditems[idx]
			def amtdue = pitem.total 
			if ( payment >= amtdue){
				payment -= amtdue 
				totalbasic += (pitem.basic + pitem.basicint)
				totalsef += (pitem.sef + pitem.sefint)
			}
			else 
			{
				pitem.partial = true;

				if (payment > pitem.firecode){
					payment -= pitem.firecode 
				}
				else{
					pitem.firecode = payment 
					payment = 0.0 
				}

				if (payment > 0.0){
					//apply proportionally
					def basicpaymentrate  = numSvc.round(pitem.basic / (pitem.basic + pitem.sef))
					def basicpayment 	= numSvc.round(payment * basicpaymentrate)
					def sefpayment 		= payment - basicpayment 

					def basicintrate    = numSvc.round(pitem.basicint / pitem.basic)
					def partialbasic    = numSvc.round(basicpayment / (1 + basicintrate))
					def partialbasicint = basicpayment - partialbasic 

					def partialbasicdisc 		= 0.0
					if (pitem.basicdisc > 0.0) {
						def basicdiscrate = numSvc.round(pitem.basicdisc / pitem.basic)
						partialbasicdisc = numSvc.round(partialbasic * basicdiscrate)
						partialbasic += partialbasicdisc
					}

					def sefintrate    	= numSvc.round(pitem.sefint / pitem.sef)
					def partialsef    	= numSvc.round(sefpayment / (1 + sefintrate))
					def partialsefint 	= sefpayment - partialsef 

					def partialsefdisc 	= 0.0
					if (pitem.sefdisc > 0.0) {
						def sefdiscrate = numSvc.round(pitem.sefdisc / pitem.sef)
						partialsefdisc = numSvc.round(partialsef * sefdiscrate)
						partialsef += partialsefdisc
					}

					def param = [
						rptledgerid  : pitem.rptledgerid,
						yeartodelete : (pitem.qtrly == 1 ? pitem.year : pitem.year + 1),
						qtrtodelete  : (pitem.qtrly == 1 ? pitem.qtr + 1 : 0 ),
					]
					if (pitem.qtrly == 1)
						em.deleteUnpartialledQtrlyItems(param)
					else 
						em.deleteUnpartialledYearlyItems(param)

					totalbasic += (partialbasic + partialbasicint)
					totalsef += (partialsef + partialsefint)

					partialinfo = [
						objid 				: pitem.objid,
						partialbasic 		: partialbasic,
						partialbasicint 	: partialbasicint,
						partialbasicdisc 	: partialbasicdisc,
						partialsef 			: partialsef,
						partialsefint 		: partialsefint,
						partialsefdisc 		: partialsefdisc,
						partialled 			: true,
						amount 				: partial,
						toyear				: pitem.year,
						toqtr				: pitem.toqtr, 
						totalbasic 			: totalbasic,
						totalsef 			: totalsef,
						partialledyear		: pitem.year,
						partialledqtr		: pitem.fromqtr,
					]
					
					em.updatePartialInfo(partialinfo)
					payment = 0.0
					break;
				}
			}
		}
		return partialinfo 
	}

}





/*============================================================================
**
** ACTION HANDLERS
**
============================================================================**/	

public class CalcBasic implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.basic = params.expr.getDecimalValue();
			ledger.basicacctid = params.basicacct.key
			ledger.revtype = params.revtype.key

			params.rptledger.basic = params.expr.getDecimalValue();
			params.rptledger.basicacctid = params.basicacct.key
			params.rptledger.revtype = params.revtype.key
		}
	}
}	

public class CalcBasicInterest implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.basicint = params.expr.getDecimalValue();
			ledger.basicintacctid = params.basicintacct.key

			params.rptledger.basicint = params.expr.getDecimalValue();
			params.rptledger.basicintacctid = params.basicintacct.key
		}
	}
}	

public class CalcBasicDiscount implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.basicdisc = params.expr.getDecimalValue();
			params.rptledger.basicdisc = params.expr.getDecimalValue();
		}
	}
}	

public class CalcBasicAmnesty implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.basicamnesty = params.expr.getDecimalValue();
			params.rptledger.basicamnesty = params.expr.getDecimalValue();
		}
	}
}	

public class CalcBasicIntAmnesty implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.basicintamnesty = params.expr.getDecimalValue();
			params.rptledger.basicintamnesty = params.expr.getDecimalValue();
		}
	}
}	



public class CalcSEF implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.sef = params.expr.getDecimalValue();
			ledger.sefacctid = params.sefacct.key
			params.rptledger.sef = params.expr.getDecimalValue();
			params.rptledger.sefacctid = params.sefacct.key
		}
	}
}	

public class CalcSEFInterest implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.sefint = params.expr.getDecimalValue();
			ledger.sefintacctid = params.sefintacct.key

			params.rptledger.sefint = params.expr.getDecimalValue();
			params.rptledger.sefintacctid = params.sefintacct.key
		}
	}
}	

public class CalcSEFDiscount implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.sefdisc = params.expr.getDecimalValue();
			params.rptledger.sefdisc = params.expr.getDecimalValue();
		}
	}
}	

public class CalcSEFAmnesty implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.sefamnesty = params.expr.getDecimalValue();
			params.rptledger.sefamnesty = params.expr.getDecimalValue();
		}
	}
}	

public class CalcSEFIntAmnesty implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.sefintamnesty = params.expr.getDecimalValue();
			params.rptledger.sefintamnesty = params.expr.getDecimalValue();
		}
	}
}	

public class CalcFireCode implements RuleActionHandler {
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.firecode = params.expr.getDecimalValue()
			ledger.firecodeacctid = params.firecodeacct.key

			params.rptledger.firecode = params.expr.getDecimalValue()
			params.rptledger.firecodeacctid = params.firecodeacct.key
		}
	}
}	
