import com.rameses.annotations.*;
import java.rmi.server.*;
import com.rameses.rules.common.*;
import com.rameses.util.*;
import com.rameses.services.extended.*;


public class RPTBillingService
{
	@ActiveDB('rptbill')
	def em 

	@Service('RPTUtil')
	def util

	@Service('Var')
	def var 

	@Service('DateService')
	def dtSvc 

	@Service('NumberService')
	def numSvc

	@Service('RPTLedgerService')
	def ledgerSvc 

	@Resource("RuleService")
	def ruleSvc;

	def RULESET = 'rptbilling'
	def FACT_PACKAGE = 'rptbilling.'
	def MAX_ADVANCE_YEARS = 3 
	

	@ProxyMethod
	public def initBill(){
		def pdate = dtSvc.parseCurrentDate()
		return [
			billdate 			: null,
			billtoyear 			: pdate.year,
			billtoqtr			: 4,
			advancebill			: false,
			fullpayment    		: true,
            qtrlypaymentavailed : false, 
            advancepayment      : false,
            currentdate 		: pdate.date,
            cy 					: pdate.year,
            ledgerids 			: [],
            ledgers 			: [],
		]
	}


	@ProxyMethod
	public def loadProperties(bill){
		bill.billdate = dtSvc.serverDate
		if (!bill.taxpayer) throw new Exception('Taxpayer is required.')
		bill.taxpayerid = bill.taxpayer.objid
		return  em.getBilledLedgers(buildParams(bill))
	}

	@ProxyMethod
	public def generateBillByLedgerId(ledgerid){
		def bill = initBill()
		bill.billdate = dtSvc.serverDate
		bill.ledgerids.add(ledgerid)
		return generateBill(bill)
	}

	/*---------------------------------------------------------------
	* Called by RPTBilling Task to recalculate and update the
	* taxes and penalties of the specified ledger
	---------------------------------------------------------------*/
	@ProxyMethod
	public void calculateBillByLedgerIdAsync(ledgerid){
		println 'Recalculating Ledger -> ' + ledgerid 
		util.required('Ledger ID', ledgerid)
		def bill = initBill()
		bill.billdate = dtSvc.serverDate
		bill.ledgerids.add(ledgerid)
		recalcBillItems(bill)
	}

	@ProxyMethod
	public void forceRecalcBill( ledgerid ) {
		util.required('Ledger ID', ledgerid)
		em.clearLedgerBillingInfoFlags([filters:'rl.objid = $P{objid}', objid:ledgerid])
		calculateBillByLedgerIdAsync(ledgerid)
	}

	@ProxyMethod
	public def generateBill( bill ) {
		util.required('Bill To Year', bill.billtoyear)
		util.required('Bill To Qtr', bill.billtoqtr)

		def maxbilltoyear = dtSvc.serverYear + MAX_ADVANCE_YEARS
		if (bill.billtoyear > maxbilltoyear){
			throw new Exception('Bill To Year must not exceed year ' +  maxbilltoyear + '.')
		}

		if (bill.billdate == null) 
			bill.billdate = dtSvc.serverDate
		else
			bill.billdate = dtSvc.parse('yyyy-MM-dd', bill.billdate)

		if (bill.advancepayment){
			if (bill.billtoyear < dtSvc.serverYear )
				throw new Exception('Advance Year must be greater than current year.')
		}
		else if (bill.advancebill){
			if ( bill.billdate < bill.currentdate )
				throw new Exception('Advance Billing Date must be greater than current date.')
		}
		
		bill.taxpayerid = bill.taxpayer?.objid 
		if (! bill.taxpayerid && ! bill.ledgerids)
			throw new Exception('Either a Taxpayer or Ledger to bill is required.')

		if (bill.advancebill && bill.billdate <= (dtSvc.serverDate - 1 ))
            throw new Exception('Advance Billing Date must be greater than current date.')

        if (bill.recalc){
        	em.clearLedgerBillingInfoFlags(buildParams(bill))
        	bill.recalc = false
        }

        insertUnpostedItems(bill)
        recalcBillItems(bill)
        rebuildLedgerItems(bill)
        bill.validuntil = dtSvc.add(bill.expirydate, '-1d')
        if (util.toBoolean(bill.loadbillitems, true) ){
			loadBillItems(bill)
			if (!bill.ledgers) 
				throw new Exception('There are no unpaid ledgers for payment.')
        }
	
		return bill
	}


	@ProxyMethod
	public void insertUnpostedItems(bill){
		em.getLedgerWithUnpostedItems(buildParams(bill)).each{ ledger -> 
			if (ledger.lastitemyear < bill.billtoyear && ledger.lastitemyear > 0){
				ledgerSvc.insertLedgerItems(ledger, ledger.lastitemyear + 1, bill.billtoyear)
			}
		}
	}


	/* NOTE: build filters based on either ledgerids or taxpayerid 
		if ledgerids are specified set filters using IN 
		else set filters using taxpayerid 
	*/
	@ProxyMethod
	public def buildParams(bill){
		def cdate = dtSvc.parseCurrentDate()
		def pdate = dtSvc.parseDate(bill.billdate, null)
		def params = [
			taxpayerid 	: bill.taxpayerid, 
			billtoyear  : bill.billtoyear, 
			billtoqtr   : bill.billtoqtr, 
			currdate    : cdate.date,
			currentyr   : cdate.year,
			currentqtr  : cdate.qtr,
			nextbilldate : bill.expirydate,
			billdate   : pdate.date,
			billyear   : pdate.year,
			billqtr    : pdate.qtr,
			rputype    : bill.rputype, 
			forpayment : 0,
		]

		if (bill.ledgerids) {
			def ids = bill.ledgerids.collect{ "'" + it + "'"}.join(',')
			params.filters = ' rl.objid IN (' + ids + ') '
		}
		else {
			params.filters = ' f.taxpayer_objid = $P{taxpayerid} '
		}

		if (bill.rputype ){
			params.filters += ' AND r.rputype = $P{rputype} '
		}

		if (bill.barangay){
			params.barangayid = bill.barangay.objid 
			params.filters += ' AND rp.barangayid = $P{barangayid}'
		}
		return params
	}

	
	def getExpiryDate(bill) {
		def dt = dtSvc.parseDate(bill.billdate,null);

		//check in database if there is qtr deadline overrides
		def qtr_deadline = em.findExpiry([qtr:dt.qtr, year:dt.year, date:dt.date])
		
		//check discount, interest overrides
		def expirydate = null;
		def expirytype = null;

		if( ! qtr_deadline ) {
			qtr_deadline = [
				expirydate : dtSvc.getQtrEndDate(dt.qtr, dt.year),
				expirytype : 'QTRDUEDATE',
			]
		}

		expirydate = dtSvc.add(qtr_deadline.expirydate, '1d');
		expirytype = qtr_deadline.expirytype;

		//check discount first
		if(expirytype?.equalsIgnoreCase("DISCOUNT")) {
			return qtr_deadline.expirydate;
		}
		
		//if there are arrears, expiry is first day of next month
		def years = bill.ledgers.items.year.flatten().unique()
		if (years.findAll{ util.toInteger(it) < dt.year}){
			return dtSvc.add(dtSvc.getMonthEndDate(dt.date), '1d')
		}

		//check for interest overrides
		if( expirytype?.equalsIgnoreCase("INTEREST")) {
			return qtr_deadline.expirydate;
		}
		
		if( qtr_deadline ) {
			return qtr_deadline.expirydate;
		}	
		else {
			return dtSvc.add(dtSvc.getMonthEndDate(dt.date), '1d')
		} 
	}


	@ProxyMethod
	public def getLedgersToRecalc(count){
		def params = [billdate:dtSvc.serverDate, _limit : count]
		return em.getLedgersToRecalc(params)
	}


	def phases = ['TAX', 'AFTER_TAX', 'PENALTY', 'AFTER_PENALTY', 'DISCOUNT', 'AFTER_DISCOUNT', 'SUMMARY']

	@ProxyMethod
	public void recalcBillItems(bill){
		bill.ledgers = getOpenLedgers(bill)
		if ( bill.ledgers) {
			def data = createFacts(bill)
			phases.each{phase ->
				ruleSvc.execute( RULESET, data.facts, data.globals, phase );
			}
			updateLedgerItemInfo(bill, data)
			bill.expirydate = getExpiryDate(bill)
			def params = buildParams(bill)
			em.updateLedgerNextBillDate(params)
			em.applyLedgerItemTaxIncentives(params)
			em.applyQuarterlyLedgerItemTaxIncentives(params)
		}
	}

	@Async
	@ProxyMethod
	public def recalcBillItemsAsync( bill ) {
		recalcBillItems(bill)	
	}


	@ProxyMethod
	public def computePartialPayment( ledger, payment  ) {
		def partial = payment 
		if (payment == null || payment == 0)
			throw new Exception('Partial Payment is required.')

		def paiditems = em.getFullyPaidItems(['rptledgerid':ledger.rptledgerid])
		def idx = 0
		def pitem = null 

		//find the item to partial and breakdown to quarterly
		def pmt = payment
		for(; idx < paiditems.size(); idx++)
		{	
			if (pmt == 0.0 ) break;

			pitem = paiditems[idx]
			def amtdue = pitem.total 
			if ( pmt >= amtdue){
				pmt -= amtdue 
			}
			else 
			{
				def bill = [insertqtrly:true, billtoyear:pitem.year, forpayment:pitem.forpayment]
				insertQtrlyLedgerItems(bill, [objid:ledger.rptledgerid])
				em.resetLedgerItemForPaymentFlag(pitem)
				em.resetQuarterlyLedgerItemForPaymentFlag(pitem)
				em.updateLedgerItemForPaymentFlagById([objid:pitem.rptledgeritemid, forpayment:0])
				em.updateQuarterlyLedgerItemForPaymentFlagByYear([rptledgerid:pitem.rptledgerid, forpayment:1, year:pitem.year])
				break;
			}

		}

		// compute partial 
		paiditems = em.getFullyPaidItems(['rptledgerid':ledger.rptledgerid])
		idx = 0 
		pitem = null 
		for(; idx < paiditems.size(); idx++)
		{
			if (payment == 0.0 ) break;

			pitem = paiditems[idx]
			def amtdue = pitem.total 
			if ( payment >= amtdue){
				payment -= amtdue 
			}
			else 
			{
				pitem.partial = true;

				if (payment > pitem.firecode){
					payment -= pitem.firecode 
				}
				else{
					pitem.firecode = payment 
					payment = 0.0 
				}

				if (payment > 0.0){
					//apply proportionally
					def basicpaymentrate  = numSvc.round(pitem.basic / (pitem.basic + pitem.sef))
					def basicpayment 	= numSvc.round(payment * basicpaymentrate)
					def sefpayment 		= payment - basicpayment 

					def basicintrate    = numSvc.round(pitem.basicint / pitem.basic)
					def partialbasic    = numSvc.round(basicpayment / (1 + basicintrate))
					def partialbasicint = basicpayment - partialbasic 

					def partialbasicdisc 		= 0.0
					if (pitem.basicdisc > 0.0) {
						def basicdiscrate = numSvc.round(pitem.basicdisc / pitem.basic)
						partialbasicdisc = numSvc.round(partialbasic * basicdiscrate)
					}

					def sefintrate    	= numSvc.round(pitem.sefint / pitem.sef)
					def partialsef    	= numSvc.round(sefpayment / (1 + sefintrate))
					def partialsefint 	= sefpayment - partialsef 

					def partialsefdisc 	= 0.0
					if (pitem.sefdisc > 0.0) {
						def sefdiscrate = numSvc.round(pitem.sefdisc / pitem.sef)
						partialsefdisc = numSvc.round(partialsef * sefdiscrate)
					}

					def partialinfo = [
						rptledgeritemqtrlyid : pitem.rptledgeritemqtrlyid,
						partialbasic 		: partialbasic,
						partialbasicint 	: partialbasicint,
						partialbasicdisc 	: partialbasicdisc,
						partialsef 			: partialsef,
						partialsefint 		: partialsefint,
						partialsefdisc 		: partialsefdisc,
					]
					em.updatePartialInfo(partialinfo)
					payment = 0.0
					break;
				}
			}
		}
		if (pitem) {
			//clear forpayment flag for items not included in the partial payment
			em.resetLedgerItemForPaymentFlag(pitem)
			em.resetQuarterlyLedgerItemForPaymentFlag(pitem)
		}
		return [amount:partial, toyear:pitem?.year, toqtr:pitem?.qtr]
	}

	def createFacts(bill){
		def pdate = dtSvc.parseDate(bill.billdate, null)

		def map = [facts:[], globals:[:], ledgers:[]]
		map.facts << new DateBean(dtSvc.serverDate)

		//create rptledgerfact 
		bill.ledgers.each{ rl ->
			createAssessedValueFacts(map, rl)
			rl.items.each{
				resetAssessmentValues(it)
				def ledger = ruleSvc.createFact(RULESET, FACT_PACKAGE+'RPTLedgerFact')
				populateFactData(ledger, it)
				ledger.numberofmonthsfromqtr  = calculateNoOfMonthsFromQtr( pdate, ledger.year, ledger.qtr )
	            ledger.numberofmonthsfromjan  = calculateNoOfMonthsFromJan( pdate, ledger.year, ledger.qtr )
	            ledger.firstqtrpaidontime     = determineFirstQtrPaidOnTime( pdate, bill, it )
	            ledger.qtrlypaymentavailed    = determineQtrlyPaymentAvailed( bill, it )
				ledger.qtrlypaymentpaidontime = util.toBoolean(it.qtrlypaymentpaidontime, false )
	            ledger.fullpayment            = ( bill.billtoqtr == 4 && rl.lastqtrpaid == 4 ? true : false )
	            ledger.advancepayment         = bill.advancepayment 
	            ledger.paidyear				  = pdate.year 
	            ledger.classification_objid	  = it.classification.objid
	            ledger.actualuse_objid	  	  = it.actualuse.objid

				map.facts << ledger 
				map.ledgers << ledger
			}
		}
		return map 
	}

	void createAssessedValueFacts(map, rl){
		def avyears = var.rptbilling_assessed_value_fact_years
		if ( !avyears ) return 
		avyears.split(',').each{ yr ->
			def ledgerfaas = em.findLedgerFaasAV([rptledgerid:rl.objid, avyear:yr])
			if (ledgerfaas){
				def avfact = ruleSvc.createFact(RULESET, FACT_PACKAGE+'AssessedValueFact')
				avfact.rptledgerid = rl.objid
				avfact.year  	   = util.toInteger(yr)
				avfact.assessedvalue  = numSvc.round(ledgerfaas.assessedvalue/4)
				map.facts << avfact 		
			}
		}

	}

	void resetAssessmentValues(item){
		item.basic = 0.0
		item.basicint = 0.0
		item.basicintpartial = 0.0
		item.basicdisc = 0.0
		item.basicamnesty = 0.0
		item.basicintamnesty = 0.0
		item.basiccredit = 0.0
		item.sef = 0.0
		item.sefint = 0.0
		item.sefintpartial = 0.0
		item.sefdisc = 0.0
		item.sefamnesty = 0.0
		item.sefintamnesty = 0.0
		item.sefcredit = 0.0
	}

	void populateFactData(target, sourceMap){
		sourceMap.keySet().each{
			try{
				target[it] = sourceMap[it]
			}
			catch(e){
				//ignore
			}
		}
	}

	@ProxyMethod
	public void rebuildLedgerItems(bill){
		def params = buildParams(bill)
		resetUnpaidQuarterlyItems(params)
		bill.ledgers = em.getBilledLedgers(params)
		bill.ledgers.each{ ledger ->
			insertQtrlyLedgerItems(bill, ledger)
		}
	}

	void loadBillItems(bill){
		def params = buildParams(bill)
		bill.ledgers.each{ ledger ->
			bill.expirydate = ledger.nextbilldate
			bill.validuntil = dtSvc.add(bill.expirydate, '-1d')
			params.rptledgerid = ledger.objid
			ledger.items = em.getPreviousBillItems(params).each{ 
								it.total = it.basicnet + it.sefnet + it.firecode 
							}
			ledger.items += em.getCurrentBillItems(params).each{
								it.total = it.basicnet + it.sefnet + it.firecode
							}
			summarizeLedgerInfo(ledger)
		}
		calcBillTotals(bill)
	}

	void resetUnpaidQuarterlyItems(params){
		//delete rptledgeritem_qtrly with ledgeritem.qtrly = 1 and lastqtrpaid = 0
		em.deleteQtrlyLedgerItems(params)
		em.resetLedgerItemQtrlyFlag(params)
	}

	@ProxyMethod
	public void insertQtrlyLedgerItems(bill, ledger){
		if (bill.billtoyear >= dtSvc.serverYear || bill.billtoqtr !=  4 || bill.insertqtrly == true){
			if (bill.forpayment == null) bill.forpayment = 0
			def params = [rptledgerid:ledger.objid, billtoyear: bill.billtoyear, forpayment:bill.forpayment]
			em.insertQtrlyLedgerItems(params)	
			em.setLedgerItemQtrlyFlag(params)	
			params.totalfirecode = em.findTotalFireCode(params).totalfirecode
			em.chargeFireCodeOnFirstQtr(params)
		}
		
	}

	void summarizeLedgerInfo(ledger){
		ledger.basic		= util.sum(ledger.items, 'basic')
		ledger.basicdp		= util.sum(ledger.items, 'basicdp')
		ledger.basicnet		= util.sum(ledger.items, 'basicnet')
		ledger.sef			= util.sum(ledger.items, 'sef')
		ledger.sefdp		= util.sum(ledger.items, 'sefdp')
		ledger.sefnet		= util.sum(ledger.items, 'sefnet')
		ledger.firecode		= util.sum(ledger.items, 'firecode')
		ledger.total		= util.sum(ledger.items, 'total')
		if (ledger.items){
			ledger.toyear 		= ledger.items.last().year
			ledger.toqtr 		= (ledger.items.last().qtr == 0 ? 4 : ledger.items.last().qtr)
		}
	}

	void calcBillTotals(bill){
		//summarize totals
		bill.totalbasic		= util.sum(bill.ledgers, 'basic')
		bill.totalbasicdp	= util.sum(bill.ledgers, 'basicdp')
		bill.totalbasicnet	= util.sum(bill.ledgers, 'basicnet')
		bill.totalsef		= util.sum(bill.ledgers, 'sef')
		bill.totalsefdp		= util.sum(bill.ledgers, 'sefdp')
		bill.totalsefnet		= util.sum(bill.ledgers, 'sefnet')
		bill.totalfirecode   = util.sum(bill.ledgers, 'firecode')
		bill.grandtotal = util.sum(bill.ledgers, 'total')
	}


	def getOpenLedgers(bill){
		def params = buildParams(bill)
		em.resetAdvanceBillFlag(params)
		def ledgers = em.getOpenLedgers(params)
		ledgers.each{ledger ->
			ledger.items = em.getOpenLedgerItemsByLedgerId([ledgerid:ledger.objid, billdate:bill.billdate]).each{
					it.qtrly = util.toBoolean(it.qtrly, false)
				}
		}
		return ledgers 
	}


	int calculateNoOfMonthsFromQtr(pdate, year, qtr) {
		if (qtr == null || qtr == 0) qtr = 1 
		int currYear = pdate.year
		int currMonth = pdate.month
		qtr = ( qtr == 0 ? 1 : qtr )
		if(year < currYear) {
			return ((currYear - year) * 12 - (3 * (qtr-1))) + currMonth 
		}
		else {
			int nm = currMonth - (3 * (qtr-1))
			return nm < 0 ? 0 : nm
		}
	}
	
	int calculateNoOfMonthsFromJan(pdate, year, qtr) {
		int currYear = pdate.year
		int currMonth = pdate.month
		int nmon = 0;
		if(year < currYear) {
			nmon = ( currYear - year ) * 12 + currMonth
		}
		else {
			nmon = currMonth
		}
		return nmon 
	}

	boolean determineFirstQtrPaidOnTime( pdate, bill, item ) {
        if( pdate.qtr == 1 && item.lastyearpaid == pdate.year -1 && item.lastqtrpaid == 4 ) return true 
        if( item.lastyearpaid == pdate.year && item.lastqtrpaid >= 1 && pdate.qtr == 1 ) return true
        return item.firstqtrpaidontime
    }

    boolean determineQtrlyPaymentAvailed( bill, item ) {
        if( bill.billtoqtr != 4 ) return true 
        if( bill.billtoqtr == 4 && item.lastqtrpaid != 4 ) return true 
        return false 
    }
	
	void updateLedgerItemInfo(bill, data){
		bill.ledgers.each{bl ->
			bl.items.each{ item ->
				def ledger = data.ledgers.find{it.objid == item.objid}
				if (ledger){
					item.basic = numSvc.round(ledger.basic)
					item.basicint = numSvc.round(ledger.basicint)
					item.basicdisc = numSvc.round(ledger.basicdisc)
					item.basicamnesty = numSvc.round(ledger.basicamnesty)
					item.basicintamnesty = numSvc.round(ledger.basicintamnesty)
					item.basiccredit = numSvc.round(ledger.basiccredit)
					item.sef = numSvc.round(ledger.sef)
					item.sefint = numSvc.round(ledger.sefint)
					item.sefdisc = numSvc.round(ledger.sefdisc)
					item.sefamnesty = numSvc.round(ledger.sefamnesty)
					item.sefintamnesty = numSvc.round(ledger.sefintamnesty)
					item.sefcredit = numSvc.round(ledger.sefcredit)
					item.firecode = numSvc.round(ledger.firecode)
					item.paidyear = ledger.paidyear 
					item.basicacct = [objid:ledger.basicacctid]
					item.basicintacct = [objid:ledger.basicintacctid]
					item.sefacct = [objid:ledger.sefacctid]
					item.sefintacct = [objid:ledger.sefintacctid]
					item.firecodeacct = [objid:ledger.firecodeacctid]
					item.revtype = (ledger.revtype ? ledger.revtype : item.revtype)
					item.partial = false
					item.partialbasic = 0.0
					item.partialbasicint = 0.0
					item.partialbasicdisc = 0.0
					item.partialbasicamnesty = 0.0
					item.partialbasicintamnesty = 0.0
					item.partialsef = 0.0
					item.partialsefint = 0.0
					item.partialsefdisc = 0.0
					item.partialsefamnesty = 0.0
					item.partialsefintamnesty = 0.0
					if (item.qtrly) {
						ledgerSvc.updateLedgerItemAccountInfo(item)
						ledgerSvc.updateLedgerItemQuarterly(item)
					}
					else{
						ledgerSvc.updateLedgerItem(item)
					}
				}
			}
		}
	}

}
	