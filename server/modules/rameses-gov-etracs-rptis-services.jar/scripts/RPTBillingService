import com.rameses.annotations.*;
import java.rmi.server.*;
import com.rameses.rules.common.*;
import com.rameses.util.*;
import com.rameses.services.extended.*;


public class RPTBillingService
{
	@ActiveDB('rptbill')
	def em 

	@ActiveDB("rule")
	def ruleDB;

	@Env
	def env

	@Service('RPTUtil')
	def util

	@Service('Var')
	def var 

	@Service('DateService')
	def dtSvc 

	@Service('NumberService')
	def numSvc

	@Service('SequenceService')
	def seqSvc

	@Service('RPTLedgerService')
	def ledgerSvc 

	@Resource("RuleService")
	def ruleSvc;

	def RULESET = 'rptbilling'
	def FACT_PACKAGE = 'rptbilling.'
	def MAX_ADVANCE_YEARS = 3 
	
	def SCHEMA_BILL_ITEM = 'billitem'

	def BARCODE_PREFIX = '56001:'

	@ProxyMethod
	public def initBill(ledgerid){
		def pdate = dtSvc.parseCurrentDate()
		return [
			billdate 			: pdate.date,
			billtoyear 			: pdate.year,
			billtoqtr			: 4,
			advancebill			: false,
			fullpayment    		: true,
            qtrlypaymentavailed : false, 
            advancepayment      : false,
            currentdate 		: pdate.date,
            cy 					: pdate.year,
            rptledgerid 		: ledgerid,
		]
	}


	@ProxyMethod
	public def saveBill(bill){
		def cy = dtSvc.serverYear
		def lguid = var.lgu_objid
		if (!lguid) throw new Exception('The lgu_objid info in sys_var must be set.')
		lguid = lguid.replaceAll('-', '')
		def b = [
			objid 			: 'B' + new java.rmi.server.UID(),
			barcode 		: BARCODE_PREFIX + lguid + cy + seqSvc.getNextFormattedSeriesA('RPTBILL-' + cy,7),
			expirydate  	: bill.ledgers[0].expirydate,
			taxpayer_objid	: bill.taxpayer.objid,
			taxpayer_name	: bill.taxpayer.name,
			taxpayer_address: bill.taxpayer.address,
			postedby		: env.NAME,
			postedbytitle	: env.JOBTITLE,
			billtoyear		: bill.billtoyear,
			billtoqtr 		: bill.billtoqtr,
		]
		em.insertRptBill(b)
		bill.ledgers.each{
			em.insertRptBillLedger([rptbillid:b.objid, rptledgerid:it.objid])
		}
		return b 
	}

	@ProxyMethod
	public def getBillByBarcode(param){
		def bill= em.findBillByBarcode(param)
		if (!bill) 
			throw new Exception('Invalid barcode or associated bill has already expired.')
		if (bill.expirydate <= dtSvc.serverDate) 
			throw new Exception('Bill has already expired.')
		bill.collectiontype = em.findCollectionTypeByBarcodeKey(param)
		if (!bill.collectiontype) 
			throw new Exception('Collection Type is not defined for barcode key ' + param.barcodekey + '.')
		bill.ledgers = em.getBillLedgers(bill)
		return bill 
	}


	@ProxyMethod
	public def loadProperties(bill){
		bill.billdate = dtSvc.serverDate
		if (!bill.taxpayer) throw new Exception('Taxpayer is required.')
		bill.taxpayerid = bill.taxpayer.objid
		return  em.getBilledLedgers(buildParams(bill))
	}


	@ProxyMethod
	public def generateBillByLedgerId(ledgerid){
		def bill = initBill(ledgerid)
		bill.billdate = dtSvc.serverDate
		return generateBill(bill)
	}


	@ProxyMethod
	public def generateBillByLedgerId2(ledgerid, billtoyear, billtoqtr ){
		def bill = initBill(ledgerid)
		bill.billdate = dtSvc.serverDate
		bill.billtoyear = billtoyear
		bill.billtoqtr = billtoqtr
		return generateBill(bill)
	}

	/*---------------------------------------------------------------
	* Called by RPTBilling Task to recalculate and update the
	* taxes and penalties of the specified ledger
	---------------------------------------------------------------*/
	@ProxyMethod
	public void calculateBillByLedgerIdAsync(ledgerid){
		def bill = initBill(ledgerid)
		bill.billdate = dtSvc.serverDate
		recalcBillItems(bill)
	}

	@ProxyMethod
	public void forceRecalcBill( ledgerid ) {
		util.required('Ledger ID', ledgerid)
		em.clearLedgerBillingInfoFlags([filters:'rl.objid = $P{objid}', objid:ledgerid])
		calculateBillByLedgerIdAsync(ledgerid)
	}


	/*==================================================================
	** - Billing is generated by Ledger
	** - clear billitems 
	** - generate bill starting from (lastyearpaid, lastqtrpaid) to billtoyear
	** - save billitems ( yr >= cy must be save as qtrly)
	===================================================================*/
	@ProxyMethod
	public def generateBill( bill ) {
		util.required('Bill To Year', bill.billtoyear)
		util.required('Bill To Qtr', bill.billtoqtr)

		def maxbilltoyear = dtSvc.serverYear + MAX_ADVANCE_YEARS
		if (bill.billtoyear > maxbilltoyear){
			throw new Exception('Bill To Year must not exceed year ' +  maxbilltoyear + '.')
		}

		if (bill.billdate == null) 
			bill.billdate = dtSvc.serverDate
		else
			bill.billdate = dtSvc.parse('yyyy-MM-dd', bill.billdate)

		if (bill.advancepayment){
			if (bill.billtoyear < dtSvc.serverYear )
				throw new Exception('Advance Year must be greater than current year.')
		}
		else if (bill.advancebill){
			if ( bill.billdate < bill.currentdate )
				throw new Exception('Advance Billing Date must be greater than current date.')
		}
		
		bill.taxpayerid = bill.taxpayer?.objid 
		if (! bill.rptledgerid)
			throw new Exception('Ledger to bill is required.')

		if (bill.advancebill && bill.billdate <= (dtSvc.serverDate - 1 ))
            throw new Exception('Advance Billing Date must be greater than current date.')

        bill.ledger = em.findOpenLedgerById(bill)
        if (!bill.ledger) throw new Exception('Ledger is fully paid or is exempted.')

        if (bill.ledger.recalcbill == 1 || bill.forceRecalcBill == true){
        	println 'Recalculating ledger -> ' + bill.ledger.tdno 
        	clearBillItems(bill)
	        def data = executeRules(bill)
	        saveBillItems(bill, data)
	        bill.expirydate = getExpiryDate(bill)
	        bill.validuntil = dtSvc.add(bill.expirydate, '-1d')
	        em.updateLedgerNextBillDate(buildParams(bill))
        }
		return bill
	}


	void clearBillItems(bill){
		em.clearBillItems(bill)
	}

	void saveBillItems(bill, data){
		data.ledgers.each{
			em.create(it, SCHEMA_BILL_ITEM)
		}
		//apply partial
		if (bill.ledger.partialled == 1) {
			em.applyPartialPayment(bill.ledger)
		}
		em.applyLedgerItemTaxIncentives(bill.ledger)
	}


	/*========================================================
	*
	* NOTE: billing is now by ledger
	*
	========================================================*/
	@ProxyMethod
	public def buildParams(bill){
		def cdate = dtSvc.parseCurrentDate()
		def pdate = dtSvc.parseDate(bill.billdate, null)
		def params = [
			rptledgerid : bill.rptledgerid,
			taxpayerid : bill.taxpayerid,
			billtoyear  : bill.billtoyear, 
			billtoqtr   : bill.billtoqtr,
			toyear  	: bill.billtoyear, 
			toqtr   	: bill.billtoqtr, 
			currdate    : cdate.date,
			currentyr   : cdate.year,
			currentqtr  : cdate.qtr,
			nextbilldate : bill.expirydate,
			billdate   : pdate.date,
			billyear   : pdate.year,
			billqtr    : pdate.qtr,
			rputype    : bill.rputype, 
			forpayment : 0,
		]
		if (bill.rptledgerid) {
			params.filters = ' rl.objid = $P{rptledgerid}'
		}
		else {
			params.filters = ' f.taxpayer_objid = $P{taxpayerid} '
		}
		if (bill.rputype ){
			params.filters += ' AND r.rputype = $P{rputype} '
		}

		if (bill.barangay){
			params.barangayid = bill.barangay.objid 
			params.filters += ' AND rp.barangayid = $P{barangayid}'
		}
		return params
	}



	/*============================================================================
	**
	** BILLING RULES SUPPORT
	**
	============================================================================**/

	@ProxyMethod
	public def executeRules(bill){
		def data = createFacts(bill)
		def actions = buildActions(bill, data)
		def grps = ruleDB.getRulegroups( [ruleset: RULESET] );
		grps.each{g ->
			ruleSvc.execute( RULESET, data.facts, actions, g.name);
		}
		return data 
	}

	def buildActions(bill, data){
		def actions = new RuleAction();
		actions.addCommand('calc-basic', new CalcBasic(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-basicint', new CalcBasicInterest(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-basicdisc', new CalcBasicDiscount(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-basic-amnesty', new CalcBasicAmnesty(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-basicint-amnesty', new CalcBasicIntAmnesty(numSvc:numSvc, ledgers:data.ledgers))

		actions.addCommand('calc-sef', new CalcSEF(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-sefint', new CalcSEFInterest(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-sefdisc', new CalcSEFDiscount(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-sef-amnesty', new CalcSEFAmnesty(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-sefint-amnesty', new CalcSEFIntAmnesty(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-firecode', new CalcFireCode(numSvc:numSvc, ledgers:data.ledgers))

		actions.addCommand('calc-brgyshare', new CalcBrgyShare(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-brgyint-share', new CalcBrgyIntShare(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-lgushare', new CalcLguShare(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-lguint-share', new CalcLguIntShare(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-provshare', new CalcProvShare(numSvc:numSvc, ledgers:data.ledgers))
		actions.addCommand('calc-provint-share', new CalcProvIntShare(numSvc:numSvc, ledgers:data.ledgers))
		return actions 
	}

	def createFacts(bill){
		def data = [facts:[], ledgers:[]]
		data.facts << new CurrentDate(dtSvc.serverDate)
		data.facts << new EffectiveDate(dtSvc.serverDate)

		//create RPTLedgerFacts
		bill.items = []
		def ledgerfaases = []
		if (bill.noledger == true)
			ledgerfaases << bill.ledger 
		else 
		 	ledgerfaases = em.getLedgerFaases(bill)

		def cy = dtSvc.serverYear
		bill.ledger.fromyear.upto(bill.billtoyear){ yr ->
			if (yr >= cy){
				createQtrlyLedgerFacts(data, bill, ledgerfaases, yr)
			}
			else{
				createYearlyLedgerFact(data, bill, ledgerfaases, yr)
			}
			data.facts << createAssessedValueFacts(data, bill.ledger, ledgerfaases)
		}
		return data 
	}


	void createQtrlyLedgerFacts(data, bill, ledgerfaases, yr){
		def ledgerfaas = ledgerfaases.find{ yr >= it.fromyear && ( yr <= it.toyear || it.toyear == 0) }
		if (!ledgerfaas){
			def xyr = yr + 1
			ledgerfaas = ledgerfaases.find{ xyr >= it.fromyear && ( xyr <= it.toyear || it.toyear == 0) }
		}
		if (!ledgerfaas) 
			throw new Exception('Ledger FAAS ' + bill.ledger.tdno +  ' for year ' + yr + ' is not defined.\nVerify RPT Ledger faas history record.')

		def qtrlyav  = numSvc.round( ledgerfaas.assessedvalue / 4)
		def fourthqtrav = ledgerfaas.assessedvalue - numSvc.round((qtrlyav * 3))

		def fromqtr = (yr == bill.ledger.fromyear ? bill.ledger.fromqtr : 1 )
		def toqtr = (yr == bill.billtoyear ? bill.billtoqtr : 4)

		fromqtr.upto(toqtr){qtr ->
			def av = qtrlyav
			if (qtr == 4) av = fourthqtrav
			def ledger = createRPTLedgerData(bill, ledgerfaas, yr, qtr, qtr, qtr, av)
			def ledgerfact = createLedgerFact(ledger)
			data.ledgers << ledger 
			data.facts << ledgerfact 
		}
	}


	void createYearlyLedgerFact(data, bill, ledgerfaases, yr){
		def ledgerfaas = ledgerfaases.find{ yr >= it.fromyear && ( yr <= it.toyear || it.toyear == 0) }
		if (!ledgerfaas){
			def xyr = yr + 1
			ledgerfaas = ledgerfaases.find{ xyr >= it.fromyear && ( xyr <= it.toyear || it.toyear == 0) }
		}
		if (!ledgerfaas) 
			throw new Exception('Ledger FAAS ' + bill.ledger.tdno +  ' for year ' + yr + ' is not defined.\nVerify RPT Ledger faas history record.')

		def qtrlyav = numSvc.round( ledgerfaas.assessedvalue / 4)
		def av      = ledgerfaas.assessedvalue

		def fromqtr = (yr == bill.ledger.fromyear ? bill.ledger.fromqtr : 1 )
		def toqtr = (yr == bill.billtoyear ? bill.billtoqtr : 4)

		if (fromqtr != 1 || toqtr != 4)
			av = qtrlyav * (toqtr - fromqtr + 1)

		def ledger = createRPTLedgerData(bill, ledgerfaas, yr, 0, fromqtr, toqtr, av)
		def ledgerfact = createLedgerFact(ledger)
		data.ledgers << ledger 
		data.facts << ledgerfact 
	}


	def createRPTLedgerData(bill, ledgerfaas, yr, qtr, fromqtr, toqtr, av){
		def pdate = dtSvc.parseDate(bill.billdate, null)
		def ledger = [:]
		resetAssessmentValues(ledger)
		ledger.objid				= 'BI' + new java.rmi.server.UID()
		ledger.rptledgerid		= bill.ledger.objid
		ledger.rptledgerfaasid  = ledgerfaas.objid
		ledger.tdno				= ledgerfaas.tdno
		ledger.year 			= yr 
		ledger.qtr 				= qtr
		ledger.fromqtr 			= fromqtr
		ledger.toqtr 			= toqtr
		ledger.originalav 		= ledgerfaas.assessedvalue 
		ledger.assessedvalue	= ledgerfaas.assessedvalue 
		ledger.barangayid 		= bill.ledger.barangayid
		ledger.av 				= av
		ledger.qtrlyav 				= av
		ledger.txntype 			= ledgerfaas.txntype.objid
		ledger.rputype 			= bill.ledger.rputype 
		ledger.classification 	= ledgerfaas.classification.objid 
		ledger.actualuse 			= ledgerfaas.actualuse.objid 
		ledger.numberofmonthsfromqtr  = calculateNoOfMonthsFromQtr( pdate, yr, qtr )
        ledger.numberofmonthsfromjan  = calculateNoOfMonthsFromJan( pdate, yr, qtr )
        ledger.firstqtrpaidontime     = determineFirstQtrPaidOnTime( pdate, bill, bill.ledger )
        ledger.qtrlypaymentavailed    = determineQtrlyPaymentAvailed( bill, bill.ledger)
		ledger.qtrlypaymentpaidontime = util.toBoolean(bill.ledger.qtrlypaymentpaidontime, false )
        ledger.fullpayment            = determineFullPayment(pdate, bill, bill.ledger, ledger) 
        ledger.advancepayment         = bill.advancepayment 
		ledger.backtax				  = ledgerfaas.backtax 
		ledger.reclassed			  = (ledgerfaas.reclassed != null ? ledgerfaas.reclassed : false)
		return ledger 
	}

	def createLedgerFact(ledger){
		def ledgerfact = ruleSvc.createFact(RULESET, FACT_PACKAGE+'RPTLedgerFact')
		populateFactData(ledgerfact, ledger)
		return ledgerfact 
	}

	void populateFactData(target, sourceMap){
		sourceMap.keySet().each{
			try{
				target[it] = sourceMap[it]
			}
			catch(e){
				//ignore
			}
		}
	}

	void createAssessedValueFacts(map, rl, ledgerfaases){
		def avyears = var.rptbilling_assessed_value_fact_years
		if ( !avyears ) return 
		avyears.split(',').each{ yr ->
			yr = util.toInteger(yr)
			def ledgerfaas = ledgerfaases.find{ yr >= it.fromyear && ( yr <= it.toyear || it.toyear == 0) }
			if (ledgerfaas){
				def avfact = ruleSvc.createFact(RULESET, FACT_PACKAGE+'AssessedValueFact')
				avfact.rptledgerid = rl.objid
				avfact.year  	   = util.toInteger(yr)
				avfact.assessedvalue  = numSvc.round(ledgerfaas.assessedvalue)
				avfact.qtrlyav = numSvc.round(ledgerfaas.assessedvalue / 4.0)
				map.facts << avfact 		
			}
		}
	}


	void resetAssessmentValues(item){
		item.basic = 0.0
		item.basicpaid = 0.0
		item.basicint = 0.0
		item.basicintpaid = 0.0
		item.basicintpartial = 0.0
		item.basicdisc = 0.0
		item.basicdisctaken = 0.0
		item.basicamnesty = 0.0
		item.basicintamnesty = 0.0
		item.basiccredit = 0.0
		item.sef = 0.0
		item.sefpaid = 0.0
		item.sefint = 0.0
		item.sefintpaid = 0.0
		item.sefintpartial = 0.0
		item.sefdisc = 0.0
		item.sefdisctaken = 0.0
		item.sefamnesty = 0.0
		item.sefintamnesty = 0.0
		item.sefcredit = 0.0
		item.firecode = 0.0
		item.firecodepaid = 0.0
		item.amnestyinfo = 0.0
		item.forpayment = false
		item.partial = false
		item.partialbasic = 0.0
		item.partialbasicint = 0.0
		item.partialbasicdisc = 0.0
		item.partialsef = 0.0
		item.partialsefint = 0.0
		item.partialsefdisc = 0.0
		item.brgyshare = 0.0
		item.brgyintshare = 0.0
		item.lgushare = 0.0
		item.lguintshare = 0.0
		item.provshare = 0.0
		item.provintshare = 0.0
	}

	int calculateNoOfMonthsFromQtr(pdate, year, qtr) {
		if (qtr == null || qtr == 0) qtr = 1 
		int currYear = pdate.year
		int currMonth = pdate.month
		qtr = ( qtr == 0 ? 1 : qtr )
		if(year < currYear) {
			return ((currYear - year) * 12 - (3 * (qtr-1))) + currMonth 
		}
		else {
			int nm = currMonth - (3 * (qtr-1))
			return nm < 0 ? 0 : nm
		}
	}
	
	int calculateNoOfMonthsFromJan(pdate, year, qtr) {
		int currYear = pdate.year
		int currMonth = pdate.month
		int nmon = 0;
		if(year < currYear) {
			nmon = ( currYear - year ) * 12 + currMonth
		}
		else {
			nmon = currMonth
		}
		return nmon 
	}

	boolean determineFirstQtrPaidOnTime( pdate, bill, item ) {
        if( pdate.qtr == 1 && item.lastyearpaid == pdate.year -1 && item.lastqtrpaid == 4 ) return true 
        if( item.lastyearpaid == pdate.year && item.lastqtrpaid >= 1 && pdate.qtr == 1 ) return true
        return item.firstqtrpaidontime
    }

    boolean determineQtrlyPaymentAvailed( bill, item ) {
        if( bill.billtoqtr != 4 ) return true 
        if( bill.billtoqtr == 4 && item.lastqtrpaid != 4 && bill.ledger?.partialled == 0 ) return true 
        return false 
    }

    boolean determineFullPayment(pdate, bill, rl, item) {
    	def fullpayment = false
		if (item.year < pdate.year && item.year == rl.lastyearpaid && bill.billtoqtr == 4) 
			fullpayment = true
		else if (item.year > rl.lastyearpaid && item.year < bill.billtoyear) 
			fullpayment = true
		else if (item.year > rl.lastyearpaid && item.year == bill.billtoyear &&  bill.billtoqtr == 4)
			fullpayment = true 
		else if (item.year == pdate.year && rl.lastqtrpaid == 4 &&  bill.billtoqtr == 4)
			fullpayment = true 

		return fullpayment
    }



	def getExpiryDate(bill) {
		def dt = dtSvc.parseDate(bill.billdate,null);

		//check in database if there is qtr deadline overrides
		def qtr_deadline = em.findExpiry([qtr:dt.qtr, year:dt.year, date:dt.date])
		
		//check discount, interest overrides
		def expirydate = null;
		def expirytype = null;

		if( ! qtr_deadline ) {
			qtr_deadline = [
				expirydate : dtSvc.getQtrEndDate(dt.qtr, dt.year),
				expirytype : 'QTRDUEDATE',
			]
		}

		expirydate = dtSvc.add(qtr_deadline.expirydate, '1d');
		expirytype = qtr_deadline.expirytype;

		//check discount first
		if(expirytype?.equalsIgnoreCase("DISCOUNT")) {
			return qtr_deadline.expirydate;
		}
		
		//if there are arrears, expiry is first day of next month
		if (bill.ledger.lastyearpaid < dt.year){
			return dtSvc.add(dtSvc.getMonthEndDate(dt.date), '1d')
		}

		//check for interest overrides
		if( expirytype?.equalsIgnoreCase("INTEREST")) {
			return qtr_deadline.expirydate;
		}
		
		if( qtr_deadline ) {
			return qtr_deadline.expirydate;
		}	
		else {
			return dtSvc.add(dtSvc.getMonthEndDate(dt.date), '1d')
		} 
	}




	@ProxyMethod
	public def computePartialPayment( ledger, payment  ) {
		def partial = payment 
		if (payment == null || payment == 0)
			throw new Exception('Partial Payment is required.')

		def paiditems = em.getFullyPaidItems(['rptledgerid':ledger.rptledgerid])
		def idx = 0
		def pitem = null 
		def partialinfo = [:]

		for(; idx < paiditems.size(); idx++)
		{
			if (payment == 0.0 ) break;

			pitem = paiditems[idx]
			def amtdue = pitem.total 
			if ( payment >= amtdue){
				payment -= amtdue 
				em.updateShareInfo(pitem)
			}
			else 
			{
				pitem.partial = true;

				if (payment > pitem.firecode){
					payment -= pitem.firecode 
				}
				else{
					pitem.firecode = payment 
					payment = 0.0 
				}

				if (payment > 0.0){
					def linetotal = pitem.total - pitem.firecode 

					def partialbasic     = numSvc.round(  payment * (pitem.basic - pitem.basicdisc) / linetotal )
					def partialbasicint  = numSvc.round(  payment * pitem.basicint / linetotal )
					def partialbasicdisc = numSvc.round(  payment * pitem.basicdisc / linetotal )

					def partialsefint  = numSvc.round(  payment * pitem.sefint / linetotal )
					def partialsefdisc = numSvc.round(  payment * pitem.sefdisc / linetotal )
					def partialsef = payment - partialsefint - partialbasic - partialbasicint 

					partialbasic += partialbasicdisc
					partialsef += partialsefdisc 

					def param = [
						rptledgerid  : pitem.rptledgerid,
						yeartodelete : (pitem.qtrly == 1 ? pitem.year : pitem.year + 1),
						qtrtodelete  : (pitem.qtrly == 1 ? pitem.qtr + 1 : 0 ),
					]
					if (pitem.qtrly == 1)
						em.deleteUnpartialledQtrlyItems(param)
					else 
						em.deleteUnpartialledYearlyItems(param)

					
					partialinfo = [
						objid 				: pitem.objid,
						partialbasic 		: partialbasic,
						partialbasicint 	: partialbasicint,
						partialbasicdisc 	: partialbasicdisc,
						partialsef 			: partialsef,
						partialsefint 		: partialsefint,
						partialsefdisc 		: partialsefdisc,
						partialled 			: true,
						amount 				: partial,
						toyear				: pitem.year,
						toqtr				: pitem.toqtr, 
						partialledyear		: pitem.year,
						partialledqtr		: pitem.fromqtr,
					]
					
					em.updatePartialInfo(partialinfo)
					
					def total = em.findPartialTotal(param)
					partialinfo.totalgeneral = total.totalgeneral
					partialinfo.totalsef = total.totalsef 

					payment = 0.0
					
					break;
				}
			}
		}
		return partialinfo 
	}

}





/*============================================================================
**
** ACTION HANDLERS
**
============================================================================**/	

public class CalcBasic implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.basic = numSvc.round(params.expr.getDecimalValue());
			ledger.basicacctid = params.basicacct.key
			ledger.revtype = params.revtype.key

			params.rptledger.basic = ledger.basic
			params.rptledger.basicacctid = params.basicacct.key
			params.rptledger.revtype = params.revtype.key
		}
	}
}	

public class CalcBasicInterest implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.basicint = numSvc.round(params.expr.getDecimalValue());
			ledger.basicintacctid = params.basicintacct.key

			params.rptledger.basicint = ledger.basicint
			params.rptledger.basicintacctid = params.basicintacct.key
		}
	}
}	

public class CalcBasicDiscount implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.basicdisc = numSvc.round(params.expr.getDecimalValue());
			params.rptledger.basicdisc = params.expr.getDecimalValue();
		}
	}
}	

public class CalcBasicAmnesty implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.basicamnesty = numSvc.round(params.expr.getDecimalValue());
			params.rptledger.basicamnesty = ledger.basicamnesty 
		}
	}
}	

public class CalcBasicIntAmnesty implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.basicintamnesty = numSvc.round(params.expr.getDecimalValue());
			params.rptledger.basicintamnesty = ledger.basicintamnesty 
		}
	}
}	



public class CalcSEF implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.sef = numSvc.round(params.expr.getDecimalValue());
			ledger.sefacctid = params.sefacct.key
			params.rptledger.sef = ledger.sef
			params.rptledger.sefacctid = params.sefacct.key
		}
	}
}	

public class CalcSEFInterest implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.sefint = numSvc.round(params.expr.getDecimalValue());
			ledger.sefintacctid = params.sefintacct.key

			params.rptledger.sefint = ledger.sefint
			params.rptledger.sefintacctid = params.sefintacct.key
		}
	}
}	

public class CalcSEFDiscount implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.sefdisc = numSvc.round(params.expr.getDecimalValue());
			params.rptledger.sefdisc = ledger.sefdisc 
		}
	}
}	

public class CalcSEFAmnesty implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.sefamnesty = numSvc.round(params.expr.getDecimalValue());
			params.rptledger.sefamnesty = ledger.sefamnesty
		}
	}
}	

public class CalcSEFIntAmnesty implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.sefintamnesty = numSvc.round(params.expr.getDecimalValue());
			params.rptledger.sefintamnesty = ledger.sefintamnesty
		}
	}
}	

public class CalcFireCode implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.firecode = numSvc.round(params.expr.getDecimalValue())
			ledger.firecodeacctid = params.firecodeacct.key

			params.rptledger.firecode = ledger.firecode
			params.rptledger.firecodeacctid = params.firecodeacct.key
		}
	}
}	


public class CalcBrgyShare implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.brgyshare = numSvc.round(params.expr.getDecimalValue())
			ledger.brgyshareacctid = params.brgyshareacct.key
			params.rptledger.brgyshare = ledger.brgyshare
			params.rptledger.brgyshareacctid = ledger.brgyshareacctid
		}
	}
}	


public class CalcBrgyIntShare implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.brgyintshare = numSvc.round(params.expr.getDecimalValue())
			ledger.brgyintshareacctid = params.brgyintshareacct.key
			params.rptledger.brgyintshare = ledger.brgyintshare
			params.rptledger.brgyintshareacctid = ledger.brgyintshareacctid
		}
	}
}	



public class CalcLguShare implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.lgushare = numSvc.round(params.expr.getDecimalValue())
		}
	}
}	


public class CalcLguIntShare implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.lguintshare = numSvc.round(params.expr.getDecimalValue())
		}
	}
}	




public class CalcProvShare implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.provshare = numSvc.round(params.expr.getDecimalValue())
			ledger.provshareacctid = params.provshareacct.key
			params.rptledger.provshare = ledger.provshare
			params.rptledger.provshareacctid = ledger.provshareacctid
		}
	}
}	


public class CalcProvIntShare implements RuleActionHandler {
	def numSvc
	def ledgers 
	public void execute(def params, def drools) {
		def ledger = ledgers.find{ it.objid == params.rptledger.objid }
		if (ledger){
			ledger.provintshare = numSvc.round(params.expr.getDecimalValue())
			ledger.provintshareacctid = params.provintshareacct.key
			params.rptledger.provintshare = ledger.provintshare
			params.rptledger.provintshareacctid = ledger.provintshareacctid
		}
	}
}