import com.rameses.annotations.*
import com.rameses.common.*
import com.rameses.services.extended.*

class RPTTaskService 
{
	@ActiveDB('rpttask')
	def em 

    @Service('DateService')
    def dtSvc

    @Service('RPTTrackingService')
    def trackingSvc

    @Service('RPTWorkflowService')
    def workflowSvc


    @Service('RPTTaskService')
    def taskSvc

    @Env
    def env 


    @ProxyMethod
    public def createTask( task ) {
        //close previous task first
        closeTask([objid:task.objid])

        task.taskid = 'T' + new java.rmi.server.UID()
        task.startdate = dtSvc.serverDate 
        task.createdby = getUserInfo()
        em.create(task)
        return task 
    }


    @ProxyMethod
    public def assignTask( task ) {
        task.assignedto = getUserInfo();
        em.update(task)
        return task
    }

    @ProxyMethod
    public def assignTaskToMe( objid ) {
        def task = findCurrentTask(objid);
        taskSvc.createNextUserTask(task);
    }

    @ProxyMethod
    public void closeTask( task ) {
        task.enddate = dtSvc.serverDate 
        em.closeTask(task)
    }


    @ProxyMethod
    public void disapproveTaskByObjid( objid, disapprovemsg) {
        def sendertask = em.findSenderTask([objid:objid])

        def currtask = findCurrentTask(objid)
        closeTask(currtask)

        //recreate task for creator 
        def task = [
            taskid      : 'T' + new java.rmi.server.UID(),
            objid       : currtask.objid,
            docname     : currtask.docname,
            refno       : currtask.refno,
            filetype    : currtask.filetype,
            startdate   : dtSvc.serverDate ,
            createdby   : getUserInfo(),
            assignedto  : sendertask.assignedto,
            enddate     : null,
            workflowid  : currtask.workflowid,
            msg         : 'Document has been returned to ' + currtask.signatory + '.',
            action      : sendertask.action,
            signatory   : sendertask.signatory,
            findings    : disapprovemsg,
        ]
        em.create(task)
    }


    @ProxyMethod
    public def createNextUserTask( task ) {
        closeTask(task)

        def nextwf = workflowSvc.findNextByWorkflowId([docname:task.docname, workflowid:task.workflowid, fromstate:task.action])

        task.taskid = 'T' + new java.rmi.server.UID()
        task.startdate = dtSvc.serverDate 
        task.createdby = getUserInfo()
        task.assignedto = getUserInfo()
        task.enddate = null
        task.workflowid = nextwf.workflowid
        task.msg = nextwf.message 
        task.action = nextwf.tostate 
        task.signatory = nextwf.signatory
        em.create(task)
        trackingSvc.updateMessage(task)
        return task
    }

    
    @ProxyMethod
    public def delete( task ) {
        em.deleteTask(task)    
    }

    def getUserInfo(){
        return [
            objid : env.USERID,
            name : env.FULLNAME,
            title : env.JOBTITLE,
        ]
    }


    @ProxyMethod
    public def findCurrentTask( objid ) {
        def task = em.findCurrentTask([objid:objid])
        if (!task) throw new Exception('Cannot open current task.')
        return task
    }
}
