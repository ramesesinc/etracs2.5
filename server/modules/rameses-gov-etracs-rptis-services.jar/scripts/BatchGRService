import com.rameses.annotations.*
import com.rameses.common.*;
import java.util.concurrent.*
import java.rmi.server.UID

class BatchGRService
{
	
	@PersistenceContext('main')
	def em

    @Env
	def env

    @Service('RPTUtil ')
    def util 
    
	@Service('GeneralRevisionService')
	def grSvc

	@Service('FAASService')
	def faasSvc 

	@Service('Var')
	def var

	@ProxyMethod
	public List getLandFaasIdForRevision( newry, barangayid ) {
		barangayid = (barangayid ? barangayid : '%')

		return em.sqlContext.createNamedQuery('batchgr:getLandFAASIdForRevision')
				.setParameters([ newry:newry, barangayid:barangayid  ])
				.resultList
	} 
	

	
	@ProxyMethod
	public def reviseLandFaas( params) {
		util.required('Land FAAS ID', params.objid)
		util.required('New RY', params.newry)
		params.newry = params.newry.ry
		//params.memoranda : optional 

		def retval = [success:0, error:0]
		
		if( ! params.memoranda ) params.memoranda = 'REVISED PURSUANT TO R.A. 7160' 
		def landfaas = reviseFaas( params, null, retval )
		if( landfaas ) {
			def improvements = faasSvc.getLandImprovements( params.objid )
			improvements.each{ improvement ->
				improvement.newry = params.newry 
				improvement.memoranda = params.memoranda 
				def faas = reviseFaas( improvement, landfaas, retval)
			}
		}
		return retval
	}
	
	@ProxyMethod
	public def reviseFaas( params, landfaas, retval  ) {
		def faas = null 
		try {
			faas = faasSvc.openFaas( params.objid )
			def newrysetting = getRySetting( faas.rpu.rputype, params.newry ) 
			faas.autonumber = util.toBoolean( var.gr_td_autonumber, false )

			faas = grSvc.initGeneralRevision([faas:faas, newrysetting:newrysetting, autonumber:faas.autonumber])
			faas.memoranda = params.memoranda 
			faas = faasSvc.createFaas( faas )
			println 'Successfully revised -> ' + faas.prevtdno 
			retval.success += 1
			return faas 
		}
		catch ( e ) {
			println '='*50
			e.printStackTrace()
			retval.error += 1
			logError( params.objid, params.newry, e ) 
		}
		return null
	}		

	@ProxyMethod
	public List getRyList( rputype ) {
		if( !rputype || 'land'.equals( rputype ) ) {
			return em.sqlContext.createNamedQuery('batchgr:getLandRYSetting').resultList 
		}
		else if( 'bldg'.equals( rputype ) ) {
			return em.sqlContext.createNamedQuery('batchgr:getBldgRYSetting').resultList 
		}
		else if( 'mach'.equals( rputype ) ) {
			return em.sqlContext.createNamedQuery('batchgr:getMachRYSetting').resultList 
		}
		else if( 'planttree'.equals( rputype ) ) {
			return em.sqlContext.createNamedQuery('batchgr:getPlantTreeRYSetting').resultList 
		}
		else if( 'misc'.equals( rputype ) ) {
			return em.sqlContext.createNamedQuery('batchgr:getMiscRYSetting').resultList 
		}
		return []
	}




	
	void logError( faasid, newry, e ) {
		def sw = null 
		def pw = null 
		try {
			em.sqlContext.createNamedExecutor('batchgr:deleteBatchGRError').setParameter('faasid', faasid).execute()
			
			sw = new StringWriter()
			pw = new PrintWriter(sw)
			e.printStackTrace( pw)
			em.sqlContext.createNamedExecutor('batchgr:insertBatchGRError')
					.setParameter('faasid', faasid)
					.setParameter('ry', newry)
					.setParameter('msg', sw.toString())
					.execute()
		}
		catch( ex ) {
			println 'Unable to Log Error for ' + faasid 
		}
		finally{
			if( sw ) try{ sw.close() } catch( ex ) {}
			if( pw ) try{ pw.close() } catch( ex ){}
		}
		
	}
	
	

	

	@ProxyMethod 
	public void validateBatchRY( newry, barangayid ) {
		barangayid = ( barangayid ? barangayid : '%')
		//checkPendingFaasTransactions( newry, barangayid )
		
		def rptsetting = em.sqlContext.createNamedQuery('batchgr:getCurrentRY').singleResult 
		if( !rptsetting ) {
			throw new Exception('RPT Setting is not defined.')
		}
		if( rptsetting.ry >= newry ) {
			throw new Exception('New Revision Year must be greater than current revision year ' + rptsetting.ry )
		}
		
		//check landry setting 
		def ry = em.sqlContext.createNamedQuery('batchgr:getRYSetting_land')
						.setParameter('ry', newry)
						.singleResult 
		if( ! ry ) throw new Exception( "Land Revision Year Setting for $newry is not defined.")
		
		//check bldgry setting 
		ry = em.sqlContext.createNamedQuery('batchgr:getRYSetting_bldg')
						.setParameter('ry', newry)
						.singleResult 
		if( ! ry ) throw new Exception( "Building Revision Year Setting for $newry is not defined.")
		
		//check machry setting 
		ry = em.sqlContext.createNamedQuery('batchgr:getRYSetting_mach')
						.setParameter('ry', newry)
						.singleResult 
		if( ! ry ) throw new Exception( "Machine Revision Year Setting for $newry is not defined.")
		
		//check planttreery setting 
		if ( existSetting( 'planttreerysetting') ){
			ry = em.sqlContext.createNamedQuery('batchgr:getRYSetting_planttree')
							.setParameter('ry', newry)
							.singleResult 
			if( ! ry ) throw new Exception( "Plant/Tree Revision Year Setting for $newry is not defined.")
		}
		
		//check getRYSetting_misc setting 
		if ( existSetting('miscrysetting') ) {
			ry = em.sqlContext.createNamedQuery('batchgr:getRYSetting_misc')
							.setParameter('ry', newry)
							.singleResult 
			if( ! ry ) throw new Exception( "Miscellaneous Revision Year Setting for $newry is not defined.")
		}
	}
	
	
	@ProxyMethod 
	public Map initGeneralRevision( faas, txntype, prevtdno, autonumber, newrysetting, landfaas ) {
		if( !newrysetting ) {
			throw new Exception('New RY Setting is required.')
		}
		
		faas = faasSvc.initReassessmentTransaction( [faas:faas, txntype:txntype, prevtdno:prevtdno, autonumber:autonumber] )
		if( faas.rpu.ry >= newrysetting.ry ) {
			throw new Exception('New Revision Year must be greater than ' + faas.rpu.ry + '.' )
		}
		
		def txn 			= faasSvc.resolveTxnType( txntype )
		faas.info.txntype	= txn.txntype 
        faas.info.txn       = txn 
		faas.info.datacapture = false
		faas.rpu.ry			= newrysetting.ry 
		
		if( landfaas ) {
			//update pin info in case pin is renumbered
			faas.rp.putAll( landfaas.rp )
			faas.rpu.fullpin 	= landfaas.rp.pin + '-' + faas.rpu.suffix
			faas.info.landfaasid = landfaas.objid 
			faas.info.landfaastaxpayerid = landfaas.info.taxpayerid
		}
		
		//recalculate due to gr 
		def rputype = faas.rpu.rputype 
		
		if( 'land'.equals( rputype )  ) {
			faas = landRpuSvc.initGeneralRevision( faas, newrysetting )
		}
		else if( 'bldg'.equals( rputype )  ) {
			faas.remove('previnfo')
			faas = bldgRpuSvc.initGeneralRevision( faas, newrysetting )
		}
		else if( 'mach'.equals( rputype )  ) {
			faas.remove('previnfo')
			faas = machRpuSvc.initGeneralRevision( faas, newrysetting )
		}
		else if( 'planttree'.equals( rputype )  ) {
			faas.remove('previnfo')
			faas = planttreeRpuSvc.initGeneralRevision( faas, newrysetting)
		}
		else if( 'misc'.equals( rputype )  ) {
			faas.remove('previnfo')
			faas = miscRpuSvc.initGeneralRevision( faas, newrysetting)
		}
		else {
			throw new Exception( 'Cannot process rpu type ' + rputype + '.' )
		}
		
		faas.info.tdno 		= faasSvc.generateNextTdNo( faas )
		
		return faas 
		
	}
	
	
	
	def getRySetting( rputype, newry ) {
		if( rputype == 'land' ) {
			return em.sqlContext.createNamedQuery('batchgr:getRYSetting_land')
						.setParameter('ry', newry)
						.singleResult 
		}
		
		if( rputype == 'bldg' ) {
			return em.sqlContext.createNamedQuery('batchgr:getRYSetting_bldg')
						.setParameter('ry', newry)
						.singleResult 
		}
		
		if( rputype == 'mach' ) {
			return em.sqlContext.createNamedQuery('batchgr:getRYSetting_mach')
						.setParameter('ry', newry)
						.singleResult 
		}
		
		if( rputype == 'planttree' ) {
			return em.sqlContext.createNamedQuery('batchgr:getRYSetting_planttree')
						.setParameter('ry', newry)
						.singleResult 
		}
		
		if( rputype == 'misc' ) {
			return em.sqlContext.createNamedQuery('batchgr:getRYSetting_misc')
						.setParameter('ry', newry)
						.singleResult 
		}
		return null 
	}
	
	boolean existSetting( setting ) {
		def list = em.sqlContext.createNamedQuery('rysetting:getSetting')
						.setVars([setting:setting])
						.resultList 
		return list.size() > 0	
	}
	
	void checkPendingFaasTransactions( newry, barangayid ) {
		//check if there are still pending faases, therefore, not current or cancelled
		def pendinglist = em.sqlContext.createNamedQuery('batchgr:getPendingFaasList')
					.setParameter('barangayid', barangayid)
					.setParameter('ry', newry)
					.setMaxResults(1)
					.resultList 
		if( pendinglist ){
			throw new Exception("There are still pending FAASes for approval.\nApprove or cancel these records before processing the general revision.")
		}
		
		//check pending subdivisions
		pendinglist = em.sqlContext.createNamedQuery('batchgr:getPendingSubdivisions')
					.setMaxResults(1)
					.resultList 
		if( pendinglist ){
			throw new Exception("There are still pending subdivisions.\nApprove or cancel these records before processing the general revision.")
		}
		
		//check pending consolidations
		pendinglist = em.sqlContext.createNamedQuery('batchgr:getPendingConsolidations')
					.setMaxResults(1)
					.resultList 
		if( pendinglist ){
			throw new Exception("There are still pending consolidations.\nApprove or cancel these records before processing the general revision.")
		}
		
		//check pending annotations
		pendinglist = em.sqlContext.createNamedQuery('batchgr:getPendingAnnotations')
					.setMaxResults(1)
					.resultList 
		if( pendinglist ){
			throw new Exception("There are still pending annotations.\nApprove or cancel these records before processing the general revision.")
		}
		
	}
	
}

