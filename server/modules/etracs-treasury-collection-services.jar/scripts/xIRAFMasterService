import com.rameses.common.*;import com.rameses.annotations.*;import com.rameses.util.*;import java.rmi.server.UID;class xIRAFMasterService{	@PersistenceContext('main')	def em		@Service('DateService')	def dateSvc;		@Service('SequenceService')	def seqSvc;		def SCHEMA_NAME = 'iraf';	def STATE_DRAFT = 'DRAFT';	def STATE_APPROVED = 'APPROVED';	def CALENDAR = Calendar.getInstance();		@ProxyMethod	public def init() {}		@ProxyMethod	public def create( iraf ) {		if( iraf.riv.type != 'PURCHASE' ) {			iraf.txnno = getNextSeries(iraf.riv.type);		}		def qry = em.sqlContext.createNamedQuery('iraf:getIrafByTxnno')						.setParameter('txnno', iraf.txnno)						.singleResult;		if( qry ) throw new Exception("IRAF No. ${iraf.txnno} already exists.");				EntityUtil.mapToField( iraf );		em.validate( SCHEMA_NAME, iraf );		def requesteditems = iraf.requesteditems;		def issueditems = iraf.issueditems;		iraf.remove('requesteditems');		iraf.remove('issueditems');		em.create( SCHEMA_NAME, iraf );		EntityUtil.fieldToMap( iraf );				requesteditems.each{ reqitem->			reqitem.irafid = iraf.objid;			EntityUtil.mapToField(reqitem);			em.validate('iraf:requesteditem', reqitem);			em.create('iraf:requesteditem', reqitem);			EntityUtil.fieldToMap(reqitem);		}		iraf.requesteditems = requesteditems;				issueditems.each{ issueditem->			issueditem.irafid = iraf.objid;			EntityUtil.mapToField(issueditem);			em.validate('iraf:issueditem', issueditem);			em.create('iraf:issueditem', issueditem);			EntityUtil.fieldToMap(issueditem);		}		iraf.issueditems = issueditems;		return iraf;	}		private def getNextSeries(def rivtype) {		def year = dateSvc.parseDate( dateSvc.serverDate, null ).year;		def sequenceKey = "IRAF-" + rivtype[0] + year;		return year + seqSvc.getNextFormattedSeriesA( sequenceKey, 6);	}		@ProxyMethod	public def update( iraf ) {		def old = open(iraf)				if( old.state != STATE_DRAFT ) throw new Exception("IRAF is already ${old.state}")				def qry = em.sqlContext.createNamedQuery('iraf:getIrafByTxnno')						.setParameter('txnno', iraf.txnno)						.singleResult;		if( qry && qry.objid != iraf.objid ) throw new Exception("IRAF No. ${iraf.txnno} already exists.");				EntityUtil.mapToField( iraf );		em.validate( SCHEMA_NAME, iraf );		def requesteditems = iraf.requesteditems;		def issueditems = iraf.issueditems;		iraf.remove('requesteditems');		iraf.remove('issueditems');		em.update( SCHEMA_NAME, iraf );		EntityUtil.fieldToMap( iraf );				requesteditems.each{ reqitem->			reqitem.irafid = iraf.objid;			EntityUtil.mapToField(reqitem);			em.validate('iraf:requesteditem', reqitem);			em.update('iraf:requesteditem', reqitem);			EntityUtil.fieldToMap(reqitem);		}		iraf.requesteditems = requesteditems;				issueditems.each{ issueditem->			issueditem.irafid = iraf.objid;			EntityUtil.mapToField(issueditem);			em.validate('iraf:issueditem', issueditem);			em.update('iraf:issueditem', issueditem);			EntityUtil.fieldToMap(issueditem);		}		iraf.issueditems = issueditems;		return iraf;	}		@ProxyMethod	public def open( iraf ) {		iraf = em.read( SCHEMA_NAME, iraf );		if( !iraf ) throw new Exception('IRAF does not exist or has already been deleted.')		EntityUtil.fieldToMap(iraf);		iraf.requesteditems = em.sqlContext.createNamedQuery('iraf:getRequestedItemsByIrafid')									.setParameter('irafid', iraf.objid)									.resultList;		iraf.requesteditems.each { reqitem->			EntityUtil.fieldToMap(reqitem);		}		iraf.issueditems = [];		def issueditems = em.sqlContext.createNamedQuery('iraf:getIssuedItemsByIrafid')								.setParameter('irafid', iraf.objid)								.resultList;		issueditems.each{ issueditem->			issueditem = em.read('iraf:issueditem', issueditem);			EntityUtil.fieldToMap(issueditem);			iraf.issueditems.add(issueditem);		}				return iraf;	}		@ProxyMethod	public def approve( iraf ) {		iraf = open(iraf);				if( iraf.state != STATE_DRAFT ) throw new Exception("IRAF is already ${iraf.state}.");				//Update RIV and RIVITEMS		iraf.riv.state = 'CLOSED';		def rivitems = iraf.riv.items;		rivitems.each{ item->			def reqitem = iraf.requesteditems.find{ it.af.objid == item.af.objid }						item.qtyissued += reqitem.qtyreceived;			reqitem.qtyreceived = 0;			reqitem.qtyissued = item.qtyissued;			if( item.qtyissued < item.qtyrequested ) iraf.riv.state = 'OPEN';						EntityUtil.mapToField(item);			//em.update('riv:rivitem', item);			EntityUtil.fieldToMap(item);		}				EntityUtil.mapToField(iraf.riv);		//em.update('riv', iraf.riv);		EntityUtil.fieldToMap(iraf.riv);						//Update IRAF		iraf.state = STATE_APPROVED;		if( iraf.riv.type == 'PURCHASE' )			postToAFInventory( iraf );		else {			postToAFInventoryCredit( iraf );		}				return update(iraf);	}			private void postToAFInventory( iraf ) {		def c = em.sqlContext.createQuery("SELECT * FROM craaf").resultList;		iraf.issueditems.each{ issueditem ->			if( issueditem.af.type == 'serial' ) {				issueditem.prefix = (issueditem.prefix? issueditem.prefix : "");				issueditem.suffix = (issueditem.suffix? issueditem.suffix : "");				def qry = em.sqlContext.createNamedQuery('iraf:checkOverlappingSeries')								.setParameters(issueditem)								.singleResult;				if( qry ) throw new Exception("There is an overlapping in series for AF Control ${issueditem.prefix} ${issueditem.startseries} - ${issueditem.endseries} ${issueditem.suffix}");			}						def af = em.sqlContext.createQuerty("SELECT * FROM af WHERE objid = ${issueditem.af.objid}")			//def af = em.sqlContext.createNamedQuery("af:getById").setParameter("objid", issueditem.af.objid).singleResult;			if( !af ) throw new Exception("AF ${issueditem.af.objid} no longer exist.");						def afi = em.sqlContext.createNamedQuery('iraf:getAFInventoryNextStubNo')									.setParameters([iraf_objid:issueditem.irafid, af_objid:issueditem.af.objid])									.singleResult;						def stubto = issueditem.stubfrom? (issueditem.stubfrom+issueditem.qtyreceived)-1 : issueditem.qtyreceived;			def afinventory = [				objid		: "AFI"+new UID(),				state		: "OPEN",				iraf		: iraf,				af			: issueditem.af,				dtposted	: dateSvc.serverDate,				currentstub	: afi? (afi.stubto+1) : issueditem.stubfrom,				stubfrom	: afi? (afi.stubto+1) : issueditem.stubfrom,				stubto		: afi? (afi.stubto+issueditem.qtyreceived) : stubto,				prefix		: issueditem.prefix? issueditem.prefix : "",				suffix		: issueditem.suffix? issueditem.suffix : "",				startseries	: issueditem.startseries,				endseries	: issueditem.endseries,				beginqty	: issueditem.receivedqty,				endqty		: issueditem.receivedqty,				iyear		: CALENDAR.get( Calendar.YEAR ),				imonth		: CALENDAR.get( Calendar.MONTH )+1			];			if( afinventory.imonth >= 1 && afinventory.imonth <= 3 ) afinventory.iqtr = 1;			else if( afinventory.imonth >= 4 && afinventory.imonth <= 6 ) afinventory.iqtr = 2;			else if( afinventory.imonth >= 7 && afinventory.imonth <= 9 ) afinventory.iqtr = 3;			else if( afinventory.imonth >= 10 && afinventory.imonth <= 12 ) afinventory.iqtr = 4;			issueditem.afinventoryid = afinventory.objid;						EntityUtil.mapToField(afinventory);			em.validate("afinventory", afinventory);			em.create("afinventory", afinventory);						if( !c ) {				def seriesfrom = "N/A";				def seriesto = "N/A";				if( issueditem.af.type == "serial" ) {					def prefix = issueditem.prefix? issueditem.prefix+"-" : "";					def suffix = issueditem.suffix? "-"+issueditem.suffix : "";					seriesfrom = prefix + issueditem.startseries + suffix;					seriesto = prefix + issueditem.endseries + suffix;				}				def craaf = [					objid			: "C"+new UID(),					afinventoryid	: afinventory.objid,					craafyear		: CALENDAR.get( Calendar.YEAR ),					craafmonth		: CALENDAR.get( Calendar.MONTH ),					afid			: issueditem.af.objid,					beginqty		: afinventory.beginqty,					beginfrom		: seriesfrom,					beginto			: seriesfrom,					endqty			: afinventory.endqty					endfrom			: seriesfrom,					endto			: seriesto				];								em.create("craaf", craaf);			}		}	}		private void postToAFInventoryCredit( def iraf ){		/*iraf.requesteditems.each{ reqitem->			for(int i=0; i<reqitem.qtyreceived; i++) {				def afinventory = em.sqlContext.createNamedQuery("iraf:getNextAFInventory")										.setParameter("af_objid", reqitem.af.objid)										.singleResult;				if( !afinventory ) throw new Exception("There are no more Accountable Forms for AF ${reqitem.af.objid} in the Inventory.");								def afinventorycredit = [					objid			: "AFIC"+new UID(),					afinventoryid	: afinventory.objid,					state			: "OPEN",					iraf			: iraf,					af				: reqitem.af,					prefix			: afinventory.prefix,					suffix			: afinventory.suffix,					stubno			: afinventory.currentstub,					startseries		: 0,					endseries		: 0,					qtyissued		: 0,					qtyissued		: 0,					balance			: reqitem.af.pcsperunit				];							afinventory.qtyonhand -= 1;				afinventory.qtyissued += 1;				afinventory.currentstub += 1;												if( reqitem.af.type == 'serial' ) {					afinventorycredit.startseries = ( afinventory.issuedfrom == 0 ) ? afinventory.startseries : (afinventory.issuedto + 1)					afinventorycredit.endseries = afinventorycredit.startseries + reqitem.af.pcsperunit - 1;										//set issuedfrom only if not yet initialized					if( ! afinventory.issuedfrom || afinventory.issuedfrom == 0 )						afinventory.issuedfrom = afinventorycredit.startseries;											afinventory.issuedto = afinventorycredit.endseries;				}								if( afinventory.qtyonhand <= 0 )					afinventory.tate = 'CLOSED';								em.update( "afinventory", afinventory );				em.validate( "afinventorycredit", afinventorycredit );				em.create( "afinventorycredit", afinventorycredit );								if( iraf.riv.type != 'PURCHASE' ) {					def afcontrol = [						objid				: "AFC"+new UID(),						state 				: "APPROVED",						dtposted			: dateSvc.serverDate,						active				: 0,						mode				: "ONLINE",						dtissued			: iraf.txndate,						afinventorycreditid	: afinventorycredit.objid,						collector			: iraf.riv,						assignedto			: iraf.riv,						prefix				: afinventorycredit.prefix,						suffix				: afinventorycredit.suffix,						stubno				: afinventorycredit.stubno,						af					: afinventorycredit.af,						qtyreceived			: afinventorycredit.balance,						startseries			: afinventorycredit.startseries,						endseries			: afinventorycredit.endseries,						currentseries		: afinventorycredit.startseries,						balance				: afinventorycredit.balance,						beginqty			: 0,						beginseries			: 0,					];					def afcontrol = [						objid: "AFC" + new UID(),						schemaname: "afcontrol:afcontrol",						schemaversion: "1.0",						docstate: "APPROVED",						dtposted: dateService.serverDate,						active: false,						mode: "ONLINE",						dtissued: iraf.info.txndate,						afinventorycreditid: afinventorycredit.objid,						collectorid: iraf.info.rivrequestedbyid,						collectorname: iraf.info.rivrequestedby,						collectortitle: iraf.info.rivrequestedbytitle,						assignedtoid: iraf.info.rivrequestedbyid,						assignedtoname: iraf.info.rivrequestedby,						assignedtotitle: iraf.info.rivrequestedbytitle,						prefix: afinventorycredit.prefix,						suffix: afinventorycredit.suffix,						stubno: afinventorycredit.stubno,						afid: afinventorycredit.afid,						aftype: afinventorycredit.aftype,						qtyreceived: afinventorycredit.balance,						startseries: afinventorycredit.startseries,						endseries: afinventorycredit.endseries,						currentseries: afinventorycredit.startseries,						balance: afinventorycredit.balance,						beginseries: 0,						beginqty: 0,						qtyissued: 0,						issuedfrom: 0,						issuedto: 0,						serieslength: afinventorycredit.aflength,						cancelledseries: [],											];										addCancelledSeriesInAFControl( afinventory, afcontrol  )										em.validate( afcontrol.schemaname, afcontrol );					em.save( afcontrol.schemaname, afcontrol );				}			}		}*/			/*iraf.requesteditems.each{ ri ->				for( int i=0; i < ri.qtyreceived; i++){				def afinventory = getNextAFInventory( ri.afid );				def af =  em.sqlContext.createNamedQuery("af:getById")							.setParameters( [objid: ri.afid] )							.singleResult;						 				def afinventorycredit = [					objid: "AFIC" + new UID(),					schemaname: 'afinventorycredit:afinventorycredit',					afinventoryid: afinventory.objid,					schemaversion: '1.0',					docstate: 'OPEN',					irafid: iraf.objid,					irafno: iraf.txnno,					iraftype: iraf.info.rivtype,					aftype: afinventory.aftype,					afid: afinventory.afid,					afunit: afinventory.afunit,					aflength: afinventory.aflength,					prefix: afinventory.prefix,					suffix: afinventory.suffix,					//stubno: afinventory.stubprefix + '-' + afinventory.currentstub,					stubno: afinventory.currentstub,					startseries: 0,					endseries: 0,					qtyissued: 0,					qtyissued: 0,					balance: ri.afpcsperunit				];							afinventory.qtyonhand -= 1;				afinventory.qtyissued += 1;				afinventory.currentstub += 1;								if( ri.aftype == 'serial' ){					afinventorycredit.startseries = ( afinventory.issuedfrom == 0 ) ? afinventory.startseries : (afinventory.issuedto + 1)					afinventorycredit.endseries = afinventorycredit.startseries + ri.afpcsperunit - 1;										//set issuedfrom only if not yet initialized					if( ! afinventory.issuedfrom || afinventory.issuedfrom == 0 ) {						afinventory.issuedfrom = afinventorycredit.startseries;					}					afinventory.issuedto = afinventorycredit.endseries;				}								if( afinventory.qtyonhand <= 0 )					afinventory.docstate = 'CLOSED';								em.update( afinventory.schemaname, afinventory );				em.validate( afinventorycredit.schemaname, afinventorycredit );				em.save( afinventorycredit.schemaname, afinventorycredit );				if( iraf.info.rivtype.matches('COLLECTOR|SALE') ){					def afcontrol = [						objid: "AFC" + new UID(),						schemaname: "afcontrol:afcontrol",						schemaversion: "1.0",						docstate: "APPROVED",						dtposted: dateService.serverDate,						active: false,						mode: "ONLINE",						dtissued: iraf.info.txndate,						afinventorycreditid: afinventorycredit.objid,						collectorid: iraf.info.rivrequestedbyid,						collectorname: iraf.info.rivrequestedby,						collectortitle: iraf.info.rivrequestedbytitle,						assignedtoid: iraf.info.rivrequestedbyid,						assignedtoname: iraf.info.rivrequestedby,						assignedtotitle: iraf.info.rivrequestedbytitle,						prefix: afinventorycredit.prefix,						suffix: afinventorycredit.suffix,						stubno: afinventorycredit.stubno,						afid: afinventorycredit.afid,						aftype: afinventorycredit.aftype,						qtyreceived: afinventorycredit.balance,						startseries: afinventorycredit.startseries,						endseries: afinventorycredit.endseries,						currentseries: afinventorycredit.startseries,						balance: afinventorycredit.balance,						beginseries: 0,						beginqty: 0,						qtyissued: 0,						issuedfrom: 0,						issuedto: 0,						serieslength: afinventorycredit.aflength,						cancelledseries: [],											];										addCancelledSeriesInAFControl( afinventory, afcontrol  )										em.validate( afcontrol.schemaname, afcontrol );					em.save( afcontrol.schemaname, afcontrol );				}								def rcvitem = [					afid: afinventorycredit.afid,					afinventoryid : afinventory.objid, 					startseries: afinventorycredit.startseries,					endseries: afinventorycredit.endseries,					prefix: afinventory.prefix,					suffix: afinventorycredit.suffix,					stubno: afinventorycredit.stubno+"",					qtyreceived: 1,								];				iraf.rcvitems.add( rcvitem );			}		}*/			}		private def getNextAFInventory( def afid  ){		def afinventory = em.sqlContext.createNamedQuery("iraf:getNextOpenAFInventory")				     .setParameters([afid: afid])					 .singleResult;		if( !afinventory ) throw new Exception("There are no more Accountable Forms for AF $afid in the Inventory.");		return afinventory;	}		@ProxyMethod	public def checkIRAFByRIV( riv ) {		def iraf = em.sqlContext.createNamedQuery('iraf:getIrafDraftByRivId')								.setParameter("riv_objid", riv.objid)								.singleResult;		if( iraf ) throw new Exception("There is currently an open IRAF( ${iraf.txnno} ) for this RIV.");	}		@ProxyMethod	public def validatePurchaseItem( iraf, item ) {		if( item.qtyreceived <= 0 ) throw new Exception("Qty received must be greater than zero.");		def reqitem = iraf.requesteditems.find{ it.af.objid == item.af.objid };		//if( !reqitem ) throw new Exception("AF $item.af.objid is not one of the requested items.");		def totalQty = reqitem.qtyreceived + item.qtyreceived + reqitem.qtydelivered;		if( totalQty  > reqitem.qtyrequested ) throw new Exception("Qty received exceeds qty requested.");		reqitem.qtyreceived += item.qtyreceived;		item.endseries = 0;				if( item.af.type == 'serial' ) {			if( item.startseries <= 0 ) throw new Exception("Start series must be greater than zero.");			if( (item.startseries % item.af.pcsperunit) != 1 ) throw new Exception("Invalid startseries.");			item.endseries = item.startseries + ( item.qtyreceived * item.af.pcsperunit ) - 1;			def receiveditem = iraf.issueditems.find{ it.af.objid == item.af.objid && it.startseries > 0 };			if( receiveditem ) {				if( receiveditem.prefix == item.prefix && receiveditem.suffix == item.suffix ) {					if( item.startseries >= receiveditem.startseries && item.startseries <= receiveditem.endseries )						throw new Exception("Conflict in issuance of series in ${item.startseries} - ${item.endseries}");					if( item.endseries >= receiveditem.startseries && item.endseries <= receiveditem.endseries )						throw new Exception("Conflict in issuance of series in ${item.startseries} - ${item.endseries}");				}			}		}		return item;	}}