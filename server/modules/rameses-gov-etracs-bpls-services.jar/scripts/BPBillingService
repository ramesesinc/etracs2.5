import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;
import com.rameses.services.extended.*;
import com.rameses.rules.common.*;

public class BPBillingService  {

	@ActiveDB("bpbilling")
	def em;

	@Resource("RuleService")
	def ruleSvc;

	@ActiveDB("rule")
	def ruleDB;

	@Service("DateService")
	def dateSvc;

	@Service("NumberService")
	def numberSvc;

	@ActiveDB("bpexpirydate")
	def expiryDate;

	@Service("BPApplicationFactBuilder")
	def appFactBuilder;


	@Env
	def env;

	String RULESET = "bpbilling";

	private def createBillDate (dt) {
		return ruleSvc.createFact( RULESET, RULESET + ".BillingDate", dt );
	}

	//check if there is expiry date specified, if not use the default date of 21
	private def createQtrDeadline( y, q ) { 
		def bd = dateSvc.getBeginningQtrDate( q, y, 1 );
		def qtrDate = dateSvc.parseDate( bd, null );
		def ed = expiryDate.findExpiryDate([year:y, qtr: q]);
		if(ed) {
			qtrDate.deadline = ed.expirydate;
		}	
		else {
			int mon = qtrDate.month;
			def smon = "-"+mon+"-";
			if( mon < 10) smon = "-0"+mon+"-"; 
			qtrDate.deadline = dateSvc.parseDate(y+smon+"20", null).date;
		}
		return ruleSvc.createFact( RULESET, RULESET + ".QtrDeadline", qtrDate );
	}

	private def createPayment(payment, billdate) {
		def m = [amtpaid:0,minamt:0,pmtdate:billdate,balance:0];
		if(payment?.amount) {
			m.amtpaid = payment.amount;
			m.balance = payment.amount;
			if(payment.minamt) m.minamt = payment.minamt;
		}
		if( payment?.pmtdate ) {
			m.pmtdate = dateSvc.parseDate( payment.pmtdate, null ).date;
		}	
		return ruleSvc.createFact( RULESET, RULESET + ".Payment", m );
	}

	//if payment does not reach the min. amt, disqualify FULLYEAR or FULLQTR
	private def createPayOption(type, qtr, paymentFact ) {
		def m = [ type:type, qtr:qtr  ];
		if(m.qtr!=null && m.qtr==4) m.type = "FULLYEAR";
		if(paymentFact.amtpaid < paymentFact.minamt) m.type = null;		
		return ruleSvc.createFact( RULESET, RULESET + ".PayOption", m );
	}

	
	def buildActions(def req) {
		def addItems = { tf, request ->
			request.items << [
				year: tf.year,
				qtr: tf.qtr,
				lob: tf.lob,
				account: tf.account,
				taxfeetype: tf.account.taxfeetype,
				amtdue: tf.amtdue,
				surcharge: tf.surcharge,
				interest: tf.interest,
				discount: tf.discount,
				total: tf.total,
				paypriority: tf.paypriority,
				deadline: tf.deadline,
				balance: tf.balance,
				receivableid: tf.receivableid
			];	
		}	
		def actions = new RuleAction();
		actions.addCommand( "split_by_qtr", new SplitByQtr( request:req, NS:numberSvc, ruleSvc: ruleSvc, RULESET:RULESET ));
		actions.addCommand( "calc_surcharge", new CalcSurcharge( request:req, NS:numberSvc ));
		actions.addCommand( "calc_interest",  new CalcInterest( request:req, NS:numberSvc ));
		actions.addCommand( "calc_discount",  new CalcDiscount( request:req, NS:numberSvc ));
		actions.addCommand( "collect_full",  new CollectFullPayment( request:req, addItems: addItems ));
		actions.addCommand( "collect_partial",  new CollectPartialPayment( request:req, addItems: addItems, NS:numberSvc ));
		return actions;
	}


	/**********************************************
	* The parameter here is the application
	**********************************************/
	@ProxyMethod
	public def getBillItems(def o) throws Exception {
		if(!o.billdate)
			throw new Exception("Please specify billdate");
		if(!o.application)
			throw new Exception("Please specify application");
		if(!o.payoption)
			throw new Exception("Please specify payoption");
		if(!o.application.taxfees || !o.application.taxfees.findAll{ (it.amount-it.amtpaid) > 0 }  )
			throw new Exception("No receivables found for this application");

		def billdate = dateSvc.parseDate( o.billdate, null );	

		//this will be used in excess payment. do not remove.
		def paymentFact = createPayment( o.payment, billdate.date );	
		
		def facts = [];
		def appFacts = appFactBuilder.buildFact( RULESET, o.application );
		facts.addAll( appFacts );

		facts << new EffectiveDate( billdate.date );
		facts << new CurrentDate( dateSvc.serverDate );
		facts << createBillDate( billdate );
		facts << createQtrDeadline( billdate.year, 1 );
		facts << createQtrDeadline( billdate.year, 2 );
		facts << createQtrDeadline( billdate.year, 3 );
		facts << createQtrDeadline( billdate.year, 4 );
		facts << paymentFact;
		facts << createPayOption( o.payoption, o.qtr, paymentFact );
		
		def request = [items: [], facts: facts];
		def actions = buildActions( request );

		//******************* EXECUTE RULES *******************************************
		def grps = ruleDB.getRulegroups( [ruleset: RULESET] );
		for( g in grps ) { 
			ruleSvc.execute( RULESET, facts, actions, g.name );
		}
		ruleSvc.execute( RULESET, facts, actions, "apply-payment" );
		//****************************************************************************

		//sort the output
		def items = request.items?.sort{ 
			(it.qtr*10) +  ((it.taxfeetype == "TAX") ? 1 : ((it.taxfeetype=="REGFEE")?2:3)) 
		};
		def result = [
			items: items,
			total_tax : items.findAll{ it.taxfeetype == "TAX" }?.sum{it.amtdue},
			total_regfee : items.findAll{ it.taxfeetype == "REGFEE" }?.sum{it.amtdue},
			total_othercharge : items.findAll{ it.taxfeetype == "OTHERCHARGE" }?.sum{it.amtdue}
		];	

		//calc totals
		result.total_tax = (result.total_tax==null) ? 0 : result.total_tax;
		result.total_regfee = (result.total_regfee==null)? 0 : result.total_regfee;
		result.total_othercharge = (result.total_othercharge==null)? 0 : result.total_othercharge;
		result.total_amtdue = numberSvc.round( result.total_tax + result.total_regfee + result.total_othercharge );
		result.excesspayment = 0;
		if(paymentFact) result.excesspayment = paymentFact.balance;

		return result;
	}

}	

/********************************************************
* specify which taxfees will be penalized in qtr basis
*********************************************************/
public class SplitByQtr implements RuleActionHandler {
	def request;
	def NS;
	def ruleSvc;
	String RULESET;
	public void execute(def params, def drools) {
		def tf = params.taxfeeaccount;
		drools.retract( tf );
		request.facts.remove( tf );

		def amount = tf.amount;
		def amtpaid = tf.amtpaid;
		def divisor = NS.round( amount / 4 );

		for( int i=1; i<=4; i++) { 
			def amt = ((i==4) ? amount : divisor);
			amount = NS.round(amount-divisor);  
			if( amtpaid >= amt ) {
				amtpaid = NS.round(amtpaid - amt);
				continue;
			}	
			def _tf = ruleSvc.createFact( RULESET, RULESET + ".TaxFeeAccount" );
			_tf.acctid = tf.acctid;
			_tf.type = tf.type;
			_tf.amount = amt;
			_tf.amtpaid = amtpaid;
			_tf.amtdue = amt - amtpaid;
			_tf.total = amt - amtpaid;
			_tf.qtr = i;
			_tf.year = tf.year;
			_tf.expired = false;
			_tf.account = tf.account;
			_tf.lob = tf.lob;
			_tf.receivableid = tf.receivableid;
			_tf.paypriority = tf.paypriority;
			request.facts << _tf;
			drools.insert( _tf );
			amtpaid = 0;		    
		}
	}
}


//Loads each variable and 
public class CalcSurcharge implements RuleActionHandler {
	def request;
	def NS;
	public void execute(def params, def drools) {
		def tf = params.taxfeeaccount;
		def amt = params.amount.doubleValue;
		tf.surcharge = NS.round(amt);
		tf.total += NS.round( tf.surcharge );
	}
}

public class CalcInterest implements RuleActionHandler {
	def request;
	def NS;
	public void execute(def params, def drools) {
		def tf = params.taxfeeaccount;
		def amt = params.amount.doubleValue;
		tf.interest = NS.round(amt);
		tf.total += NS.round( tf.interest );
	}
}

public class CalcDiscount implements RuleActionHandler {
	def request;
	def NS;
	public void execute(def params, def drools) {
		def tf = params.taxfeeaccount;
		def amt = params.amount.doubleValue;
		tf.discount = NS.round(amt);
		tf.total -= NS.round( tf.discount );
	}
}

public class CollectFullPayment implements RuleActionHandler {
	def request;
	def addItems;
	public void execute(def tf, def drools) {
		addItems( tf, request );
	}
}

public class CollectPartialPayment implements RuleActionHandler {
	def request;
	def addItems;
	def NS;
	public void execute(def m, def drools) {
		def tf = m.taxfeeaccount;
		def partialpmt = m.amtpaid;
		def oldAmt = tf.total;

		//distribute amount partially
		tf.amtdue = NS.round( tf.amtdue / tf.total * partialpmt );
		if( tf.surcharge > 0.0 ) {
			tf.surcharge = NS.round( tf.surcharge / tf.total * partialpmt );
		}
		if( tf.interest > 0.0 ) {
			tf.interest = NS.round( partialpmt - tf.amtdue - tf.surcharge );
		}
		if( tf.discount > 0.0 ) tf.discount = NS.round( tf.discount / tf.total * partialpmt )
		tf.total = NS.round( tf.amtdue + tf.surcharge + tf.interest - tf.discount );
		tf.balance = NS.round( oldAmt - tf.total );

		addItems( tf, request );
	}
}

