import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;


/**********************************************************
* This routine is hooked in the CashReceiptService and 
* CashReceiptVoidService services. It will update each
* receivable based on amount paid. It sufficient amount 
* is paid, the application is changed from 'payment' to 
* 'release' state. How to determine how much amount is
* sufficient ? One method is by looking at the deadline 
* for each billing item compared with the receipt date. 
* We get the first expiry date, which is 1st qtr date for
* renew. If all items are paid prior to this date, then
* application will be released.      
**********************************************************/
public class BusinessCashReceiptInterceptor {

	@ActiveDB("businesscashreceipt")
	def cashRct;
	
	@ActiveDB("business")
	def biz;

	@ActiveDB("bpapplication")
	def application;

	@Service("NumberService")
	def numberSvc;

	@After(pattern="CashReceiptService.open", eval="#{result.collectiontype.handler == 'bpls'}") 
	public void onOpen(def evt) {
		def p = evt.result;
		def b = cashRct.read( p );
		if(!b) b = [tradename:'']; 	
		p.paidby = p.paidby + " ( " + b.tradename + " ) ";
	}	

	@After(pattern="CashReceiptService.post", eval="#{result.collectiontype.handler == 'bpls'}")
	public void postBusinessPayment(def evt) {
		def result = evt.result;

		//for printing purposes:
		result.payerdetails = result.paidby + " (" + result.tradename + ") " + "\n" + result.paidbyaddress;

		cashRct.save( result );
		result.items.each {
			it.parentid = result.objid;
			cashRct.save(it, "item");
		}

		result.billitems.each {
			println "DEADLINE IS " + it.deadline;
			def m = [:]
			m.objid = "BPRCVPMT"+ new UID();
			m.receivableid = it.receivableid;
			m.businessid = result.businessid;
			m.iyear = it.year;
			m.iqtr = it.qtr;
			m.refno = result.receiptno;
			m.reftype = "cashreceipt";
			m.refdate = result.receiptdate;
			m.refid = result.objid;
			m.amtpaid = it.amtdue;
			m.surchargepaid = it.surcharge;
			m.interestpaid = it.interest;
			m.discount = it.discount;
			m.voided = 0;
			biz.create( m, "receivable_payment");
		}
		
		throw new Exception("break it!");

		//summarize by receivableid
		def grps = result.billitems.groupBy{ it.receivableid };
		def ids = [];
		grps.each { k,v->
			def discount = numberSvc.round( v.sum{ it.discount } );
			def amtpaid = numberSvc.round( v.sum{ it.amtdue} );
			if(!discount) discount = 0;
			if(!amtpaid) amtpaid = 0;
			biz.updateReceivablePayment( [receivableid: k, amtpaid:amtpaid, discount: discount] );
			ids << k;
		}

		/* 
		* check unpaid balance in the application
		*   if 0 then change state of application to release.
		*/
		String receivableIds = "'" + ids.join("','") + "'";
		def list = biz.getReceivableBalances( [receivableids: receivableIds] );
		for( app in list ) {
			if( app.balance <= 0 ) {
				application.changeState( [state:'release', objid: app.applicationid ] );
			}
		}
	}

	//hook for void cash receipts
	@After(pattern="CashReceiptVoidService.post", eval="#{result.receipt.collectiontype.handler == 'bpls'}")
	public void voidTxn(def evt) {
		def rct = evt.result.receipt;
		def list = biz.getReceivablePaymentForVoiding(  [receiptid: rct.objid ] );
		def grps = list.groupBy{ it.receivableid }
		def ids = [];
		grps.each {k,v->
			def z = [ receivableid: k, 
					 amtpaid: numberSvc.round( v.sum{ it.amtpaid } ),
					 discount: numberSvc.round( v.sum{ it.discount } ),
				   ];
			biz.reverseReceivablePayment(z);
			ids << k;
		}
		biz.updateReceivablePaymentForVoiding(  [receiptid: rct.objid ] );
		//reverse the application back to paymet status.
		String receivableIds = "'" + ids.join("','") + "'";
		def applist = biz.getReceivableBalances( [receivableids: receivableIds] );
		for( app in applist ) {
			application.changeState( [state:'payment', objid: app.applicationid ] );
		}

	}


}