import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;


/**********************************************************
* This routine is hooked in the CashReceiptService and 
* CashReceiptVoidService services. It will update each
* receivable based on amount paid. It sufficient amount 
* is paid, the application is changed from 'payment' to 
* 'release' state. How to determine how much amount is
* sufficient ? One method is by looking at the deadline 
* for each billing item compared with the receipt date. 
* We get the first expiry date, which is 1st qtr date for
* renew. If all items are paid prior to this date, then
* application will be released.      
**********************************************************/
public class BusinessCashReceiptInterceptor {

	@ActiveDB("bpledger")
	def bpledger;
	
	@ActiveDB("bpapplication")
	def application;

	@Service("NumberService")
	def numberSvc;

	@After(pattern="CashReceiptService.post", eval="#{result.collectiontype.handler == 'bpls'}")
	public void postBusinessPayment(def evt) {

		def result = evt.result;
		def pmt = [:];
		pmt.objid = "BPPMT"+new UID();
		pmt.businessid = result.businessid;
		pmt.applicationid = result.applicationid;
		pmt.qtr = result.qtr;
		pmt.payoption = result.payoption;
		pmt.refno = result.receiptno;
		pmt.refdate = result.receiptdate;
		pmt.receiptid = result.objid;
		pmt.amount = result.amount;
		pmt.remarks = null;
		pmt.voided = 0;
		bpledger.create( pmt, "payment" );
		
		result.billitems.each {
			def m = [:]
			m.objid = "BPRCVPMT"+ new UID();
			m.receivableid = it.receivableid;
			m.businessid = result.businessid;
			m.paymentid = pmt.objid;
			m.iyear = it.year;
			m.iqtr = it.qtr;
			m.refid = result.objid;
			m.amtpaid = it.amtdue;
			m.surchargepaid = it.surcharge;
			m.interestpaid = it.interest;
			m.discount = it.discount;
			m.voided = 0;
			bpledger.create( m, "receivableitem");
		}
		
		//summarize by receivableid
		def grps = result.billitems.groupBy{ it.receivableid };
		def ids = [];
		grps.each { k,v->
			def discount = numberSvc.round( v.sum{ it.discount } );
			def amtpaid = numberSvc.round( v.sum{ it.amtdue} );
			if(!discount) discount = 0;
			if(!amtpaid) amtpaid = 0;
			bpledger.updateReceivablePayment( [receivableid: k, amtpaid:amtpaid, discount: discount] );
			ids << k;
		}
		//check the receivable balance of the application. before today due date.
		if( pmt.qtr > 0 ) {
			application.changeState( [objid: pmt.applicationid, state:'release'] );	
		}
	}

	//hook for void cash receipts
	@After(pattern="CashReceiptVoidService.post", eval="#{result.receipt.collectiontype.handler == 'bpls'}")
	public void voidTxn(def evt) {
		def rct = evt.result.receipt;
		def list = biz.getReceivablePaymentForVoiding(  [receiptid: rct.objid ] );
		def grps = list.groupBy{ it.receivableid }
		def ids = [];
		grps.each {k,v->
			def z = [ receivableid: k, 
					 amtpaid: numberSvc.round( v.sum{ it.amtpaid } ),
					 discount: numberSvc.round( v.sum{ it.discount } ),
				   ];
			biz.reverseReceivablePayment(z);
			ids << k;
		}
		biz.updateReceivablePaymentForVoiding(  [receiptid: rct.objid ] );
		//reverse the application back to paymet status.
		String receivableIds = "'" + ids.join("','") + "'";
		def applist = biz.getReceivableBalances( [receivableids: receivableIds] );
		for( app in applist ) {
			application.changeState( [state:'payment', objid: app.applicationid ] );
		}

	}


}